<!DOCTYPE html>
<html>
<head>
  <title>å‰ç«¯ä¸å¯è§æ°´å°ç¤ºä¾‹ï¼ˆæ”¹è¿›ç‰ˆ - ä¿®å¤ä¹±ç ï¼‰</title>
  <style>
    .container { max-width: 800px; margin: 20px auto; padding: 20px; }
    .controls { margin: 10px 0; }
    canvas { border: 1px solid #ccc; max-width: 100%; }
    .result { margin: 10px 0; padding: 10px; background-color: #f0f0f0; }
    .error { color: red; }
  </style>
</head>
<body>
  <div class="container">
    <h3>å‰ç«¯ä¸å¯è§æ°´å°ï¼ˆLSBç®—æ³• - æ”¯æŒä¸­æ–‡ - ä¿®å¤ä¹±ç ç‰ˆï¼‰</h3>
    <div class="controls">
      <input type="file" id="imageInput" accept="image/*">
      <input type="text" id="watermarkText" placeholder="è¾“å…¥æ°´å°æ–‡æœ¬" value="ç‰ˆæƒæ‰€æœ‰ Â© 2024">
      <button onclick="embedWatermark()">åµŒå…¥æ°´å°</button>
      <button onclick="extractWatermark()">æå–æ°´å°</button>
      <button onclick="testWatermark()" style="background-color: #007bff; color: white;">æµ‹è¯•åŠŸèƒ½</button>
    </div>
    <canvas id="canvas"></canvas>
    <div id="result" class="result"></div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resultDiv = document.getElementById('result');

    // æ–‡æœ¬è½¬äºŒè¿›åˆ¶ï¼ˆæ”¯æŒUTF-8ï¼‰
    function textToBits(text) {
      try {
        // ä½¿ç”¨TextEncoderå°†æ–‡æœ¬è½¬æ¢ä¸ºUTF-8å­—èŠ‚
        const encoder = new TextEncoder();
        const bytes = encoder.encode(text);
        
        const bits = [];
        // æ·»åŠ å­—èŠ‚é•¿åº¦ï¼ˆ32ä½æ•´æ•°ï¼Œæ”¯æŒæ›´é•¿æ–‡æœ¬ï¼‰
        const length = bytes.length;
        for (let i = 31; i >= 0; i--) {
          bits.push((length >> i) & 1);
        }
        
        // æ·»åŠ å­—èŠ‚å†…å®¹
        for (let i = 0; i < bytes.length; i++) {
          const byte = bytes[i];
          for (let j = 7; j >= 0; j--) {
            bits.push((byte >> j) & 1);
          }
        }
        
        // æ·»åŠ ç»“æŸæ ‡å¿—ï¼ˆ8ä¸ª1ï¼‰
        for (let i = 0; i < 8; i++) {
          bits.push(1);
        }
        
        return bits;
      } catch (error) {
        console.error('æ–‡æœ¬è½¬äºŒè¿›åˆ¶å¤±è´¥:', error);
        throw new Error('æ–‡æœ¬ç¼–ç å¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¾“å…¥å†…å®¹');
      }
    }

    // äºŒè¿›åˆ¶è½¬æ–‡æœ¬ï¼ˆæ”¯æŒUTF-8ï¼‰
    function bitsToText(bits) {
      try {
        // æ£€æŸ¥æœ€å°‘ä½æ•°
        if (bits.length < 40) { // è‡³å°‘éœ€è¦32ä½é•¿åº¦ + 8ä½ç»“æŸæ ‡å¿—
          throw new Error('æ•°æ®å¤ªçŸ­ï¼Œæ— æ³•è§£ç ');
        }
        
        // è¯»å–å‰32ä½ä½œä¸ºå­—èŠ‚é•¿åº¦
        let length = 0;
        for (let i = 0; i < 32; i++) {
          length = (length << 1) | bits[i];
        }
        
        // éªŒè¯é•¿åº¦çš„åˆç†æ€§
        if (length <= 0 || length > 10000) { // é™åˆ¶æœ€å¤§é•¿åº¦é˜²æ­¢å†…å­˜æº¢å‡º
          throw new Error(`æ— æ•ˆçš„æ•°æ®é•¿åº¦: ${length}`);
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„ä½æ•°
        const requiredBits = 32 + length * 8 + 8; // é•¿åº¦ + æ•°æ® + ç»“æŸæ ‡å¿—
        if (bits.length < requiredBits) {
          throw new Error(`æ•°æ®ä¸å®Œæ•´ï¼Œéœ€è¦${requiredBits}ä½ï¼Œå®é™…${bits.length}ä½`);
        }
        
        // æå–å­—èŠ‚æ•°æ®
        const bytes = new Uint8Array(length);
        for (let i = 0; i < length; i++) {
          let byte = 0;
          for (let j = 0; j < 8; j++) {
            byte = (byte << 1) | bits[32 + i * 8 + j];
          }
          bytes[i] = byte;
        }
        
        // éªŒè¯ç»“æŸæ ‡å¿—ï¼ˆ8ä¸ªè¿ç»­çš„1ï¼‰
        const endMarkerStart = 32 + length * 8;
        for (let i = 0; i < 8; i++) {
          if (bits[endMarkerStart + i] !== 1) {
            throw new Error('ç»“æŸæ ‡å¿—éªŒè¯å¤±è´¥ï¼Œæ°´å°å¯èƒ½å·²æŸå');
          }
        }
        
        // ä½¿ç”¨TextDecoderå°†å­—èŠ‚è½¬æ¢å›æ–‡æœ¬
        const decoder = new TextDecoder('utf-8', { fatal: true });
        return decoder.decode(bytes);
      } catch (error) {
        console.error('äºŒè¿›åˆ¶è½¬æ–‡æœ¬å¤±è´¥:', error);
        throw new Error(`æ°´å°è§£ç å¤±è´¥: ${error.message}`);
      }
    }

    // åµŒå…¥æ°´å°
    async function embedWatermark() {
      const file = document.getElementById('imageInput').files[0];
      const watermarkText = document.getElementById('watermarkText').value;
      
      if (!file) {
        resultDiv.innerHTML = '<span class="error">è¯·é€‰æ‹©å›¾ç‰‡</span>';
        return;
      }
      
      if (!watermarkText) {
        resultDiv.innerHTML = '<span class="error">è¯·è¾“å…¥æ°´å°æ–‡æœ¬</span>';
        return;
      }

      try {
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        resultDiv.textContent = 'æ­£åœ¨å¤„ç†å›¾ç‰‡...';
        
        // åŠ è½½å›¾ç‰‡
        const img = new Image();
        img.src = URL.createObjectURL(file);
        await new Promise(resolve => img.onload = resolve);
        
        // è®¾ç½®Canvaså°ºå¯¸
        canvas.width = img.width;
        canvas.height = img.height;
        
        // ç»˜åˆ¶åŸå›¾
        ctx.drawImage(img, 0, 0);
        
        // è·å–åƒç´ æ•°æ®
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;
        
        // æ–‡æœ¬è½¬äºŒè¿›åˆ¶
        const watermarkBits = textToBits(watermarkText);
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„åƒç´ å­˜å‚¨æ°´å°
        const maxBits = pixels.length / 4 * 3;
        if (watermarkBits.length > maxBits) {
          const requiredPixels = Math.ceil(watermarkBits.length * 4 / 3);
          resultDiv.innerHTML = `<span class="error">æ°´å°æ–‡æœ¬å¤ªé•¿ï¼Œå›¾ç‰‡å®¹é‡ä¸è¶³ã€‚éœ€è¦è‡³å°‘ ${requiredPixels} åƒç´ çš„å›¾ç‰‡</span>`;
          return;
        }
        
        // åµŒå…¥æ°´å°åˆ°åƒç´ æœ€ä½ä½
        let bitIndex = 0;
        for (let i = 0; i < pixels.length && bitIndex < watermarkBits.length; i += 4) {
          for (let c = 0; c < 3; c++) { // åªå¤„ç†Rã€Gã€Bé€šé“
            if (bitIndex < watermarkBits.length) {
              // æ¸…é™¤æœ€ä½ä½å¹¶è®¾ç½®ä¸ºæ°´å°ä½
              pixels[i + c] = (pixels[i + c] & 0xFE) | watermarkBits[bitIndex];
              bitIndex++;
            }
          }
        }
        
        // æ›´æ–°Canvas
        ctx.putImageData(imageData, 0, 0);
        
        // ç¡®ä¿ä»¥æ— æŸæ ¼å¼ä¿å­˜ï¼ˆPNGï¼‰
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png', 1.0); // è´¨é‡è®¾ä¸ºæœ€é«˜
        link.download = 'watermarked.png';
        link.textContent = 'ä¸‹è½½å¸¦æ°´å°å›¾ç‰‡ (PNGæ ¼å¼)';
        link.style.display = 'block';
        link.style.marginTop = '10px';
        link.style.padding = '8px 16px';
        link.style.backgroundColor = '#4CAF50';
        link.style.color = 'white';
        link.style.textDecoration = 'none';
        link.style.borderRadius = '4px';
        
        resultDiv.innerHTML = '<span style="color: green;">âœ… æ°´å°å·²æˆåŠŸåµŒå…¥åˆ°å›¾ç‰‡ä¸­</span>';
        resultDiv.appendChild(link);
        
        // æ˜¾ç¤ºè¯¦ç»†çš„æ°´å°ç»Ÿè®¡ä¿¡æ¯
        const info = document.createElement('div');
        info.style.marginTop = '10px';
        info.style.fontSize = '14px';
        info.innerHTML = `
          <strong>æ°´å°ä¿¡æ¯:</strong><br/>
          â€¢ åŸå§‹æ–‡æœ¬: "${watermarkText}"<br/>
          â€¢ å­—ç¬¦æ•°é‡: ${watermarkText.length} ä¸ª<br/>
          â€¢ UTF-8å­—èŠ‚: ${new TextEncoder().encode(watermarkText).length} å­—èŠ‚<br/>
          â€¢ å ç”¨ä½æ•°: ${watermarkBits.length} ä½<br/>
          â€¢ ä½¿ç”¨åƒç´ : ${Math.ceil(watermarkBits.length/3)} ä¸ª<br/>
          â€¢ å›¾ç‰‡å®¹é‡: ${Math.floor(pixels.length/4*3)} ä½ (åˆ©ç”¨ç‡: ${(watermarkBits.length/(pixels.length/4*3)*100).toFixed(2)}%)
        `;
        resultDiv.appendChild(info);
        
        // æ·»åŠ é‡è¦æç¤º
        const warning = document.createElement('div');
        warning.style.marginTop = '10px';
        warning.style.padding = '8px';
        warning.style.backgroundColor = '#fff3cd';
        warning.style.border = '1px solid #ffeeba';
        warning.style.borderRadius = '4px';
        warning.style.fontSize = '12px';
        warning.innerHTML = `
          <strong>âš ï¸ é‡è¦æç¤º:</strong><br/>
          â€¢ è¯·ä¿å­˜ä¸ºPNGæ ¼å¼ä»¥ä¿æŒæ°´å°å®Œæ•´æ€§<br/>
          â€¢ é¿å…å†æ¬¡å‹ç¼©æˆ–æ ¼å¼è½¬æ¢<br/>
          â€¢ JPEGç­‰æœ‰æŸæ ¼å¼ä¼šç ´åæ°´å°æ•°æ®
        `;
        resultDiv.appendChild(warning);
      } catch (error) {
        resultDiv.innerHTML = `<span class="error">åµŒå…¥æ°´å°å¤±è´¥: ${error.message}</span>`;
        console.error('åµŒå…¥æ°´å°é”™è¯¯:', error);
      }
    }

    // æå–æ°´å°
    async function extractWatermark() {
      const file = document.getElementById('imageInput').files[0];
      
      if (!file) {
        resultDiv.innerHTML = '<span class="error">è¯·é€‰æ‹©å¸¦æ°´å°çš„å›¾ç‰‡</span>';
        return;
      }

      try {
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        resultDiv.textContent = 'æ­£åœ¨æå–æ°´å°...';
        
        // åŠ è½½å›¾ç‰‡
        const img = new Image();
        img.src = URL.createObjectURL(file);
        await new Promise(resolve => img.onload = resolve);
        
        // è®¾ç½®Canvaså°ºå¯¸
        canvas.width = img.width;
        canvas.height = img.height;
        
        // ç»˜åˆ¶åŸå›¾
        ctx.drawImage(img, 0, 0);
        
        // è·å–åƒç´ æ•°æ®
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;
        
        // ä»åƒç´ ä¸­æå–äºŒè¿›åˆ¶æ°´å°
        const extractedBits = [];
        let endMarkerFound = false;
        let consecutiveOnes = 0;
        let processedPixels = 0;
        
        for (let i = 0; i < pixels.length && !endMarkerFound; i += 4) {
          processedPixels++;
          for (let c = 0; c < 3; c++) { // åªå¤„ç†Rã€Gã€Bé€šé“
            const bit = pixels[i + c] & 1; // è·å–æœ€ä½ä½
            extractedBits.push(bit);
            
            // æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°ç»“æŸæ ‡å¿—ï¼ˆ8ä¸ªè¿ç»­çš„1ï¼‰
            if (bit === 1) {
              consecutiveOnes++;
              if (consecutiveOnes === 8) {
                endMarkerFound = true;
                // ç§»é™¤åˆšæ·»åŠ çš„ç»“æŸæ ‡å¿—ä½ï¼Œåªä¿ç•™æ•°æ®éƒ¨åˆ†
                for (let j = 0; j < 8; j++) {
                  extractedBits.pop();
                }
                break;
              }
            } else {
              consecutiveOnes = 0;
            }
          }
        }
        
        if (!endMarkerFound) {
          // å°è¯•æ™ºèƒ½æ£€æµ‹ï¼šåŸºäºé•¿åº¦å­—æ®µè®¡ç®—é¢„æœŸçš„æ•°æ®é•¿åº¦
          if (extractedBits.length >= 32) {
            try {
              // è¯»å–å‰32ä½ä½œä¸ºé•¿åº¦
              let length = 0;
              for (let i = 0; i < 32; i++) {
                length = (length << 1) | extractedBits[i];
              }
              
              // æ£€æŸ¥é•¿åº¦æ˜¯å¦åˆç†
              if (length > 0 && length <= 1000) {
                const expectedTotalBits = 32 + length * 8;
                if (extractedBits.length >= expectedTotalBits) {
                  // æˆªå–åˆ°é¢„æœŸé•¿åº¦ï¼Œå¹¶æ·»åŠ ç»“æŸæ ‡å¿—è¿›è¡Œè§£ç 
                  const validBits = extractedBits.slice(0, expectedTotalBits);
                  // æ·»åŠ ç»“æŸæ ‡å¿—ç”¨äºéªŒè¯
                  for (let i = 0; i < 8; i++) {
                    validBits.push(1);
                  }
                  
                  const extractedText = bitsToText(validBits);
                  resultDiv.innerHTML = `<span style="color: orange;">æ™ºèƒ½æå–çš„æ°´å°æ–‡æœ¬: "${extractedText}"</span>`;
                  
                  const info = document.createElement('div');
                  info.textContent = `æ³¨æ„ï¼šæœªæ‰¾åˆ°å®Œæ•´ç»“æŸæ ‡å¿—ï¼Œä½¿ç”¨æ™ºèƒ½æ£€æµ‹æ¨¡å¼æå–`;
                  resultDiv.appendChild(info);
              return;
                }
              }
            } catch (e) {
              console.error('æ™ºèƒ½æå–å¤±è´¥:', e);
            }
          }
          
          resultDiv.innerHTML = '<span class="error">æœªæ‰¾åˆ°æ°´å°æˆ–æ°´å°å·²æŸåã€‚è¯·ç¡®ä¿ï¼š<br/>1. å›¾ç‰‡åŒ…å«æ°´å°<br/>2. å›¾ç‰‡æœªç»è¿‡å‹ç¼©å¤„ç†<br/>3. å›¾ç‰‡æ ¼å¼ä¸ºPNG</span>';
          return;
        }
        
        // è½¬æ¢ä¸ºæ–‡æœ¬
        const extractedText = bitsToText(extractedBits);
        
        // æ˜¾ç¤ºæˆåŠŸæå–çš„ç»“æœ
        resultDiv.innerHTML = '<span style="color: green;">âœ… æ°´å°æå–æˆåŠŸ!</span>';
        
        // æ˜¾ç¤ºæå–çš„æ–‡æœ¬
        const textResult = document.createElement('div');
        textResult.style.marginTop = '10px';
        textResult.style.padding = '10px';
        textResult.style.backgroundColor = '#d4edda';
        textResult.style.border = '1px solid #c3e6cb';
        textResult.style.borderRadius = '4px';
        textResult.innerHTML = `<strong>æå–çš„æ°´å°æ–‡æœ¬:</strong><br/>"${extractedText}"`;
        resultDiv.appendChild(textResult);
        
        // æ˜¾ç¤ºè¯¦ç»†çš„æå–ç»Ÿè®¡ä¿¡æ¯
        const info = document.createElement('div');
        info.style.marginTop = '10px';
        info.style.fontSize = '14px';
        const dataLength = new TextEncoder().encode(extractedText).length;
        info.innerHTML = `
          <strong>æå–ç»Ÿè®¡:</strong><br/>
          â€¢ å¤„ç†åƒç´ : ${processedPixels} ä¸ª<br/>
          â€¢ æå–æ•°æ®: ${extractedBits.length} ä½<br/>
          â€¢ å­—ç¬¦æ•°é‡: ${extractedText.length} ä¸ª<br/>
          â€¢ UTF-8å­—èŠ‚: ${dataLength} å­—èŠ‚<br/>
          â€¢ æ•°æ®å®Œæ•´: æ˜¯ (æ‰¾åˆ°ç»“æŸæ ‡å¿—)
        `;
        resultDiv.appendChild(info);
      } catch (error) {
        resultDiv.innerHTML = `<span class="error">æå–æ°´å°å¤±è´¥: ${error.message}</span>`;
        console.error('æå–æ°´å°é”™è¯¯:', error);
      }
    }

    // æµ‹è¯•æ°´å°åŠŸèƒ½
    async function testWatermark() {
      try {
        resultDiv.textContent = 'æ­£åœ¨ç”Ÿæˆæµ‹è¯•å›¾ç‰‡å¹¶æµ‹è¯•æ°´å°åŠŸèƒ½...';
        
        // åˆ›å»ºä¸€ä¸ªæµ‹è¯•å›¾ç‰‡ï¼ˆçº¯è‰²å›¾ç‰‡ï¼‰
        const testCanvas = document.createElement('canvas');
        testCanvas.width = 200;
        testCanvas.height = 150;
        const testCtx = testCanvas.getContext('2d');
        
        // å¡«å……æ¸å˜èƒŒæ™¯
        const gradient = testCtx.createLinearGradient(0, 0, 200, 150);
        gradient.addColorStop(0, '#4CAF50');
        gradient.addColorStop(1, '#45a049');
        testCtx.fillStyle = gradient;
        testCtx.fillRect(0, 0, 200, 150);
        
        // æ·»åŠ ä¸€äº›æ–‡å­—è®©å›¾ç‰‡æ›´æœ‰ç‰¹å¾
        testCtx.fillStyle = 'white';
        testCtx.font = '16px Arial';
        testCtx.textAlign = 'center';
        testCtx.fillText('æµ‹è¯•å›¾ç‰‡', 100, 75);
        testCtx.font = '12px Arial';
        testCtx.fillText('Test Image', 100, 95);
        
        // è®¾ç½®ä¸»Canvas
        canvas.width = testCanvas.width;
        canvas.height = testCanvas.height;
        ctx.drawImage(testCanvas, 0, 0);
        
        // æµ‹è¯•æ°´å°æ–‡æœ¬
        const testText = 'æµ‹è¯•æ°´å° ğŸ”’ Test 123';
        
        // åµŒå…¥æ°´å°
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;
        const watermarkBits = textToBits(testText);
        
        // æ£€æŸ¥å®¹é‡
        const maxBits = pixels.length / 4 * 3;
        if (watermarkBits.length > maxBits) {
          resultDiv.innerHTML = '<span class="error">æµ‹è¯•å¤±è´¥ï¼šæµ‹è¯•å›¾ç‰‡å®¹é‡ä¸è¶³</span>';
          return;
        }
        
        // åµŒå…¥æ°´å°
        let bitIndex = 0;
        for (let i = 0; i < pixels.length && bitIndex < watermarkBits.length; i += 4) {
          for (let c = 0; c < 3; c++) {
            if (bitIndex < watermarkBits.length) {
              pixels[i + c] = (pixels[i + c] & 0xFE) | watermarkBits[bitIndex];
              bitIndex++;
            }
          }
        }
        
        // æ›´æ–°Canvas
        ctx.putImageData(imageData, 0, 0);
        
        // ç«‹å³æå–æ°´å°è¿›è¡ŒéªŒè¯
        const verifyImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const verifyPixels = verifyImageData.data;
        
        // æå–æ°´å°ä½
        const extractedBits = [];
        let endMarkerFound = false;
        let consecutiveOnes = 0;
        
        for (let i = 0; i < verifyPixels.length && !endMarkerFound; i += 4) {
          for (let c = 0; c < 3; c++) {
            const bit = verifyPixels[i + c] & 1;
            extractedBits.push(bit);
            
            if (bit === 1) {
              consecutiveOnes++;
              if (consecutiveOnes === 8) {
                endMarkerFound = true;
                for (let j = 0; j < 8; j++) {
                  extractedBits.pop();
                }
                break;
              }
            } else {
              consecutiveOnes = 0;
            }
          }
        }
        
        if (!endMarkerFound) {
          resultDiv.innerHTML = '<span class="error">æµ‹è¯•å¤±è´¥ï¼šæœªæ‰¾åˆ°ç»“æŸæ ‡å¿—</span>';
          return;
        }
        
        // è§£ç æ°´å°
        const extractedText = bitsToText(extractedBits);
        
        // éªŒè¯ç»“æœ
        const success = extractedText === testText;
        
        if (success) {
          resultDiv.innerHTML = '<span style="color: green;">âœ… æµ‹è¯•æˆåŠŸï¼æ°´å°åŠŸèƒ½æ­£å¸¸å·¥ä½œ</span>';
          
          const details = document.createElement('div');
          details.style.marginTop = '10px';
          details.style.padding = '10px';
          details.style.backgroundColor = '#d4edda';
          details.style.border = '1px solid #c3e6cb';
          details.style.borderRadius = '4px';
          details.innerHTML = `
            <strong>æµ‹è¯•ç»“æœ:</strong><br/>
            â€¢ åŸå§‹æ–‡æœ¬: "${testText}"<br/>
            â€¢ æå–æ–‡æœ¬: "${extractedText}"<br/>
            â€¢ åŒ¹é…ç»“æœ: âœ… å®Œå…¨åŒ¹é…<br/>
            â€¢ å¤„ç†ä½æ•°: ${watermarkBits.length} ä½<br/>
            â€¢ å›¾ç‰‡å°ºå¯¸: ${canvas.width}Ã—${canvas.height}
          `;
          resultDiv.appendChild(details);
        } else {
          resultDiv.innerHTML = '<span class="error">âŒ æµ‹è¯•å¤±è´¥ï¼šæå–çš„æ°´å°ä¸åŒ¹é…</span>';
          
          const details = document.createElement('div');
          details.style.marginTop = '10px';
          details.innerHTML = `
            åŸå§‹: "${testText}"<br/>
            æå–: "${extractedText}"
          `;
          resultDiv.appendChild(details);
        }
        
      } catch (error) {
        resultDiv.innerHTML = `<span class="error">æµ‹è¯•å¤±è´¥: ${error.message}</span>`;
        console.error('æµ‹è¯•é”™è¯¯:', error);
      }
    }
  </script>
</body>
</html>