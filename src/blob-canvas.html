<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>å›¾ç‰‡ç¼–è¾‘ä¸å¤„ç†</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .upload-area {
      border: 2px dashed #ccc;
      border-radius: 10px;
      padding: 20px;
      text-align: center;
      margin: 20px 0;
      cursor: pointer;
      transition: border-color 0.3s;
    }
    .upload-area:hover {
      border-color: #007bff;
    }
    .upload-area.dragover {
      border-color: #007bff;
      background-color: #f8f9fa;
    }
    canvas { 
      border: 1px solid #ccc; 
      max-width: 100%;
      display: block;
      margin: 20px auto;
    }
    button { 
      margin: 5px; 
      padding: 8px 16px; 
      border: none;
      border-radius: 4px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    button:hover {
      background-color: #0056b3;
    }
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .controls {
      text-align: center;
      margin: 20px 0;
    }
    .drawing-controls {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin: 20px 0;
    }
    .control-group {
      margin: 10px 0;
    }
    label {
      display: inline-block;
      width: 80px;
      text-align: right;
      margin-right: 10px;
    }
    input[type="color"], input[type="range"], input[type="number"] {
      margin: 0 10px;
    }
    #textInput {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 200px;
    }
    .editor-layout {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }
    .canvas-section, .preview-section {
      flex: 1;
    }
    .canvas-section h3, .preview-section h3 {
      margin: 0 0 10px 0;
      color: #333;
      text-align: center;
    }
    .preview-container {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 10px;
      background-color: #f9f9f9;
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #previewImg {
      max-width: 100%;
      max-height: 400px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      display: block;
    }
    .preview-container:empty::before {
      content: "ç­‰å¾…é¢„è§ˆ...";
      color: #666;
      font-style: italic;
    }
    @media (max-width: 768px) {
      .editor-layout {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <h1>å›¾ç‰‡ç¼–è¾‘ä¸å¤„ç†</h1>
  
  <div class="upload-area" id="uploadArea">
    <p>ç‚¹å‡»æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„ä¸Šä¼ </p>
    <input type="file" id="fileInput" accept="image/*" style="display: none;">
  </div>
  
  <div style="display: block;" id="canvasContainer">
    <div class="editor-layout">
      <div class="canvas-section">
        <h3>ç¼–è¾‘åŒºåŸŸ</h3>
        <canvas id="myCanvas"></canvas>
      </div>
      
      <div class="preview-section">
        <h3>å®æ—¶é¢„è§ˆ</h3>
        <div class="preview-container">
          <img id="previewImg" src="" alt="å®æ—¶é¢„è§ˆ">
        </div>
      </div>
    </div>
    
    <div class="drawing-controls">
      <h3>ç»˜åˆ¶å·¥å…·</h3>
      
      <div class="control-group">
        <label>ç»˜åˆ¶æ¨¡å¼ï¼š</label>
        <select id="drawMode">
          <option value="text">æ–‡å­—</option>
          <option value="circle">åœ†å½¢</option>
          <option value="rectangle">çŸ©å½¢</option>
          <option value="line">ç›´çº¿</option>
          <option value="arrow">ç®­å¤´</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>é¢œè‰²ï¼š</label>
        <input type="color" id="colorPicker" value="#ff0000">
      </div>
      
      <div class="control-group">
        <label>çº¿æ¡ç²—ç»†ï¼š</label>
        <input type="range" id="lineWidth" min="1" max="20" value="3">
        <span id="lineWidthValue">3</span>px
      </div>
      
      <div class="control-group" id="textControls">
        <label>æ–‡å­—å†…å®¹ï¼š</label>
        <input type="text" id="textInput" placeholder="è¾“å…¥è¦æ·»åŠ çš„æ–‡å­—" value="ç¤ºä¾‹æ–‡å­—">
        <label>å­—ä½“å¤§å°ï¼š</label>
        <input type="number" id="fontSize" min="10" max="100" value="30">px
      </div>
      
      <div class="control-group">
        <button id="clearBtn">æ¸…é™¤ç»˜åˆ¶</button>
        <button id="resetBtn">é‡ç½®å›¾ç‰‡</button>
        <button id="testBtn" style="background-color: #ff9800; font-weight: bold;">ğŸ§ª æµ‹è¯•é¢„è§ˆ</button>
      </div>
    </div>
    
    <div class="controls">
      <button id="downloadPngBtn">ä¸‹è½½ PNG</button>
      <button id="downloadJpgBtn">ä¸‹è½½ JPEG</button>
    </div>
  </div>
  
  <script>
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const canvasContainer = document.getElementById('canvasContainer');
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const previewImg = document.getElementById('previewImg');
    
    // æ§åˆ¶å…ƒç´ 
    const drawMode = document.getElementById('drawMode');
    const colorPicker = document.getElementById('colorPicker');
    const lineWidth = document.getElementById('lineWidth');
    const lineWidthValue = document.getElementById('lineWidthValue');
    const textInput = document.getElementById('textInput');
    const fontSize = document.getElementById('fontSize');
    const textControls = document.getElementById('textControls');
    
    let originalImage = null;
    let isDrawing = false;
    let startX, startY;
    let drawings = []; // å­˜å‚¨æ‰€æœ‰ç»˜åˆ¶å†…å®¹
    
    // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥å…ƒç´ 
    console.log('=== é¡µé¢åˆå§‹åŒ–æ£€æŸ¥ ===');
    console.log('Upload area:', uploadArea);
    console.log('File input:', fileInput);
    console.log('Canvas container:', canvasContainer);
    console.log('Canvas:', canvas);
    console.log('Preview img:', previewImg);
    console.log('========================');
    
    // æ–‡ä»¶ä¸Šä¼ å¤„ç†
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', handleDragOver);
    uploadArea.addEventListener('drop', handleDrop);
    fileInput.addEventListener('change', handleFileSelect);
    
    // ç»˜åˆ¶æ¨¡å¼åˆ‡æ¢
    drawMode.addEventListener('change', (e) => {
      console.log('drawMode.value', e.target.value);
      textControls.style.display = drawMode.value === 'text' ? 'block' : 'none';
    });
    
    // çº¿æ¡ç²—ç»†æ˜¾ç¤º
    lineWidth.addEventListener('input', () => {
      lineWidthValue.textContent = lineWidth.value;
    });
    
    // æ–‡å­—è¾“å…¥å®æ—¶é¢„è§ˆ
    textInput.addEventListener('input', () => {
      if (drawMode.value === 'text' && drawings.length > 0) {
        // æ›´æ–°æœ€åä¸€ä¸ªæ–‡å­—ç»˜åˆ¶çš„å†…å®¹
        const lastDrawing = drawings[drawings.length - 1];
        if (lastDrawing && lastDrawing.type === 'text') {
          lastDrawing.text = textInput.value || 'ç¤ºä¾‹æ–‡å­—';
          redrawCanvas();
          updatePreview();
        }
      }
    });
    
    // å­—ä½“å¤§å°å®æ—¶é¢„è§ˆ
    fontSize.addEventListener('input', () => {
      if (drawMode.value === 'text' && drawings.length > 0) {
        // æ›´æ–°æœ€åä¸€ä¸ªæ–‡å­—ç»˜åˆ¶çš„å­—ä½“å¤§å°
        const lastDrawing = drawings[drawings.length - 1];
        if (lastDrawing && lastDrawing.type === 'text') {
          lastDrawing.fontSize = fontSize.value;
          redrawCanvas();
          updatePreview();
        }
      }
    });
    
    // Canvas é¼ æ ‡äº‹ä»¶
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    // æŒ‰é’®äº‹ä»¶
    document.getElementById('clearBtn').addEventListener('click', clearDrawings);
    document.getElementById('resetBtn').addEventListener('click', resetImage);
    document.getElementById('testBtn').addEventListener('click', testPreview);
    document.getElementById('downloadPngBtn').addEventListener('click', () => downloadImage('png'));
    document.getElementById('downloadJpgBtn').addEventListener('click', () => downloadImage('jpeg'));
    
    function handleDragOver(e) {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    }
    
    function handleDrop(e) {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        loadImage(files[0]);
      }
    }
    
    function handleFileSelect(e) {
      console.log('handleFileSelect', e.target.files);
      const file = e.target.files[0];
      if (file) {
        loadImage(file);
      }
    }
    
    function loadImage(file) {
      if (!file.type.startsWith('image/')) {
        alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          originalImage = img;
          setupCanvas(img);
          canvasContainer.style.display = 'block';
          drawings = []; // æ¸…ç©ºç»˜åˆ¶è®°å½•
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
    
    function setupCanvas(img) {
      // è®¾ç½®canvaså°ºå¯¸ï¼Œä¿æŒå›¾ç‰‡æ¯”ä¾‹
      const maxWidth = 600;
      const maxHeight = 400;
      let { width, height } = img;
      
      if (width > maxWidth) {
        height = (height * maxWidth) / width;
        width = maxWidth;
      }
      if (height > maxHeight) {
        width = (width * maxHeight) / height;
        height = maxHeight;
      }
      
      canvas.width = width;
      canvas.height = height;
      
      // ç»˜åˆ¶åŸå§‹å›¾ç‰‡
      ctx.drawImage(img, 0, 0, width, height);
      
      // ç«‹å³æ›´æ–°é¢„è§ˆ
      updatePreview();
    }
    
    function startDrawing(e) {
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      
      if (drawMode.value === 'text') {
        drawText(startX, startY);
        isDrawing = false;
        updatePreview();
      }
    }
    
    function draw(e) {
      if (!isDrawing) return;
      
      const rect = canvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      
      // é‡ç»˜å›¾ç‰‡å’Œæ‰€æœ‰ç»˜åˆ¶å†…å®¹
      redrawCanvas();
      
      // é¢„è§ˆå½“å‰ç»˜åˆ¶
      ctx.strokeStyle = colorPicker.value;
      ctx.lineWidth = lineWidth.value;
      ctx.lineCap = 'round';
      
      switch (drawMode.value) {
        case 'line':
          drawLine(startX, startY, currentX, currentY);
          break;
        case 'rectangle':
          drawRectangle(startX, startY, currentX - startX, currentY - startY);
          break;
        case 'circle':
          const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
          drawCircle(startX, startY, radius);
          break;
        case 'arrow':
          drawArrow(startX, startY, currentX, currentY);
          break;
      }
      
      // å®æ—¶æ›´æ–°é¢„è§ˆ
      updatePreview();
    }
    
    function stopDrawing(e) {
      if (!isDrawing) return;
      isDrawing = false;
      
      const rect = canvas.getBoundingClientRect();
      const endX = e.clientX - rect.left;
      const endY = e.clientY - rect.top;
      
      // ä¿å­˜ç»˜åˆ¶å†…å®¹
      const drawing = {
        type: drawMode.value,
        color: colorPicker.value,
        lineWidth: lineWidth.value,
        startX,
        startY,
        endX,
        endY
      };
      
      if (drawMode.value === 'circle') {
        drawing.radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
      }
      
      drawings.push(drawing);
      updatePreview();
    }
    
    function drawText(x, y) {
      const text = textInput.value || 'ç¤ºä¾‹æ–‡å­—';
      const size = fontSize.value;
      
      // ç¡®ä¿æ–‡å­—åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶
      ctx.save(); // ä¿å­˜å½“å‰çŠ¶æ€
      ctx.font = `${size}px Arial`;
      ctx.fillStyle = colorPicker.value;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
      ctx.fillText(text, x, y);
      ctx.restore(); // æ¢å¤çŠ¶æ€
      
      // ä¿å­˜æ–‡å­—ç»˜åˆ¶
      drawings.push({
        type: 'text',
        text,
        fontSize: size,
        color: colorPicker.value,
        x,
        y
      });
    }
    
    function drawLine(x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    
    function drawRectangle(x, y, width, height) {
      ctx.beginPath();
      ctx.rect(x, y, width, height);
      ctx.stroke();
    }
    
    function drawCircle(x, y, radius) {
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    function drawArrow(x1, y1, x2, y2) {
      const headLength = 20;
      const angle = Math.atan2(y2 - y1, x2 - x1);
      
      // ç”»çº¿
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // ç”»ç®­å¤´
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
      ctx.stroke();
    }
    
    function redrawCanvas() {
      // æ¸…ç©ºcanvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // é‡ç»˜åŸå§‹å›¾ç‰‡
      if (originalImage) {
        ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
      }
      
      // é‡ç»˜æ‰€æœ‰ç»˜åˆ¶å†…å®¹
      drawings.forEach(drawing => {
        if (drawing.type === 'text') {
          ctx.save();
          ctx.font = `${drawing.fontSize}px Arial`;
          ctx.fillStyle = drawing.color;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'alphabetic';
          ctx.fillText(drawing.text, drawing.x, drawing.y);
          ctx.restore();
        } else {
          ctx.save();
          ctx.strokeStyle = drawing.color;
          ctx.lineWidth = drawing.lineWidth;
          ctx.lineCap = 'round';
          
          switch (drawing.type) {
            case 'line':
              drawLine(drawing.startX, drawing.startY, drawing.endX, drawing.endY);
              break;
            case 'rectangle':
              drawRectangle(drawing.startX, drawing.startY, drawing.endX - drawing.startX, drawing.endY - drawing.startY);
              break;
            case 'circle':
              drawCircle(drawing.startX, drawing.startY, drawing.radius);
              break;
            case 'arrow':
              drawArrow(drawing.startX, drawing.startY, drawing.endX, drawing.endY);
              break;
          }
          ctx.restore();
        }
      });
    }
    
    function clearDrawings() {
      drawings = [];
      redrawCanvas();
      updatePreview();
    }
    
    function resetImage() {
      drawings = [];
      if (originalImage) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
      }
      updatePreview();
    }
    
    function updatePreview() {
      try {
        // æ£€æŸ¥canvasçŠ¶æ€
        if (!canvas || canvas.width === 0 || canvas.height === 0) {
          console.error('Canvasæ— æ•ˆæˆ–å°ºå¯¸ä¸º0');
          return;
        }
        
        // è·å–canvasçš„æ•°æ®URL
        const dataURL = canvas.toDataURL('image/png', 1.0);
        console.log('ç”Ÿæˆé¢„è§ˆï¼Œæ•°æ®é•¿åº¦:', dataURL.length);
        
        // æ›´æ–°é¢„è§ˆå›¾ç‰‡
        const previewElement = document.getElementById('previewImg');
        if (previewElement) {
          previewElement.src = dataURL;
          previewElement.style.display = 'block';
          previewElement.style.maxWidth = '100%';
          previewElement.style.height = 'auto';
          console.log('é¢„è§ˆæ›´æ–°æˆåŠŸï¼');
        } else {
          console.error('é¢„è§ˆå…ƒç´ æœªæ‰¾åˆ°');
        }
      } catch (error) {
        console.error('é¢„è§ˆæ›´æ–°é”™è¯¯:', error);
      }
    }
    
    // æµ‹è¯•é¢„è§ˆåŠŸèƒ½
    function testPreview() {
      console.log('=== æµ‹è¯•é¢„è§ˆåŠŸèƒ½å¼€å§‹ ===');
      
      // å¼ºåˆ¶æ˜¾ç¤ºå®¹å™¨
      document.getElementById('canvasContainer').style.display = 'block';
      
      // è®¾ç½®Canvaså°ºå¯¸å¹¶åˆ›å»ºæµ‹è¯•å†…å®¹
      canvas.width = 400;
      canvas.height = 300;
      
      // æ¸…ç©ºCanvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ç»˜åˆ¶æµ‹è¯•èƒŒæ™¯
      ctx.fillStyle = '#e3f2fd';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // ç»˜åˆ¶è¾¹æ¡†
      ctx.strokeStyle = '#2196f3';
      ctx.lineWidth = 3;
      ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
      
      // ç»˜åˆ¶æ ‡é¢˜æ–‡å­—
      ctx.fillStyle = '#1976d2';
      ctx.font = 'bold 24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('æµ‹è¯•é¢„è§ˆæ•ˆæœ', canvas.width / 2, 60);
      
      // ç»˜åˆ¶æè¿°æ–‡å­—
      ctx.fillStyle = '#333';
      ctx.font = '16px Arial';
      ctx.fillText('è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å›¾åƒ', canvas.width / 2, 100);
      ctx.fillText('é¢„è§ˆåŠŸèƒ½æ­£å¸¸å·¥ä½œ', canvas.width / 2, 130);
      
      // ç»˜åˆ¶å‡ ä¸ªå›¾å½¢å…ƒç´ 
      // åœ†å½¢
      ctx.fillStyle = '#ff5722';
      ctx.beginPath();
      ctx.arc(120, 180, 30, 0, Math.PI * 2);
      ctx.fill();
      
      // çŸ©å½¢
      ctx.fillStyle = '#4caf50';
      ctx.fillRect(200, 150, 60, 60);
      
      // ä¸‰è§’å½¢
      ctx.fillStyle = '#ff9800';
      ctx.beginPath();
      ctx.moveTo(320, 150);
      ctx.lineTo(290, 210);
      ctx.lineTo(350, 210);
      ctx.closePath();
      ctx.fill();
      
      // åº•éƒ¨æ–‡å­—
      ctx.fillStyle = '#666';
      ctx.font = '14px Arial';
      ctx.fillText('Canvasç»˜åˆ¶å®Œæˆ - ' + new Date().toLocaleTimeString(), canvas.width / 2, 250);
      
      console.log('æµ‹è¯•å†…å®¹ç»˜åˆ¶å®Œæˆï¼ŒCanvaså°ºå¯¸:', canvas.width, 'x', canvas.height);
      
      // ç«‹å³æ›´æ–°é¢„è§ˆ
      updatePreview();
      
      console.log('=== æµ‹è¯•é¢„è§ˆåŠŸèƒ½ç»“æŸ ===');
    }
    
    function downloadImage(format) {
      const mimeType = format === 'png' ? 'image/png' : 'image/jpeg';
      const quality = format === 'jpeg' ? 0.9 : undefined;
      
      canvas.toBlob((blob) => {
        if (!blob) {
          alert('ä¸‹è½½å¤±è´¥');
          return;
        }
        
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `edited-image.${format}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, mimeType, quality);
    }
  </script>
</body>
</html>