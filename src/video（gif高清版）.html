<!DOCTYPE html>
<html>
<head>
  <title>è§†é¢‘è½¬GIFå·¥å…·ï¼ˆæœ¬åœ°ç‰ˆï¼‰</title>
  <meta charset="UTF-8">
  <style>
    .container { 
      max-width: 900px; 
      margin: 20px auto; 
      padding: 20px; 
      font-family: Arial, sans-serif;
    }
    .preview { 
      display: flex; 
      gap: 20px; 
      margin: 20px 0; 
      flex-wrap: wrap;
    }
    video { 
      max-width: 400px; 
      border: 1px solid #ccc; 
      border-radius: 4px;
    }
    #gifResult { 
      max-width: 400px; 
    }
    .controls { 
      margin: 15px 0; 
      display: flex; 
      flex-wrap: wrap; 
      gap: 15px; 
      align-items: center;
    }
    .controls label {
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-weight: bold;
    }
    .controls input {
      padding: 5px;
      border: 1px solid #ddd;
      border-radius: 3px;
    }
    button { 
      padding: 10px 20px; 
      cursor: pointer; 
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      font-weight: bold;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .status { 
      color: #666; 
      margin: 15px 0; 
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 4px;
      border-left: 4px solid #2196F3;
    }
    .error {
      color: #d32f2f;
      background-color: #ffebee;
      border-left-color: #d32f2f;
    }
    .success {
      color: #388e3c;
      background-color: #e8f5e8;
      border-left-color: #388e3c;
    }
    .gif-preview img {
      max-width: 100%;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .download-btn {
      display: inline-block;
      padding: 8px 16px;
      background-color: #2196F3;
      color: white;
      text-decoration: none;
      border-radius: 4px;
      margin-top: 10px;
      font-weight: bold;
    }
    .download-btn:hover {
      background-color: #1976D2;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ğŸ¬ è§†é¢‘è½¬GIFå·¥å…·ï¼ˆæœ¬åœ°ç‰ˆï¼‰</h2>
    <p>æ”¯æŒå¸¸è§è§†é¢‘æ ¼å¼ï¼Œçº¯æœ¬åœ°å®ç°ï¼Œæ— éœ€å¤–éƒ¨ä¾èµ–</p>
    
    <input type="file" accept="video/*" id="videoInput" />
    
    <div class="controls">
      <label>
        æˆªå–æ—¶é•¿ï¼ˆç§’ï¼‰
        <input type="number" id="duration" value="3" min="1" max="20">
      </label>
      <label>
        GIFå¸§ç‡ï¼ˆfpsï¼‰
        <input type="number" id="fps" value="8" min="3" max="15">
      </label>
      <label>
        ç¼©æ”¾æ¯”ä¾‹
        <input type="number" id="scale" value="0.5" min="0.2" max="1" step="0.1">
      </label>
      <button onclick="startConvert()" id="convertBtn" disabled>ç”ŸæˆGIF</button>
      <button onclick="testGif()" style="background-color: #FF9800;">æµ‹è¯•åŠŸèƒ½</button>
    </div>
    
    <div class="status" id="status">è¯·é€‰æ‹©è§†é¢‘æ–‡ä»¶å¼€å§‹ä½¿ç”¨</div>
    
    <div class="preview">
      <div>
        <h4>åŸè§†é¢‘é¢„è§ˆ</h4>
        <video id="video" controls></video>
      </div>
      <div id="gifResult">
        <h4>GIFç»“æœ</h4>
        <div class="gif-preview"></div>
      </div>
    </div>
  </div>

  <script>
    const videoInput = document.getElementById('videoInput');
    const video = document.getElementById('video');
    const durationInput = document.getElementById('duration');
    const fpsInput = document.getElementById('fps');
    const scaleInput = document.getElementById('scale');
    const statusDiv = document.getElementById('status');
    const gifResult = document.getElementById('gifResult');
    const convertBtn = document.getElementById('convertBtn');
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
    function showStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
    }

    // åŠ è½½è§†é¢‘
    videoInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) {
        convertBtn.disabled = true;
        return;
      }
      
      // æ£€æŸ¥æ–‡ä»¶ç±»å‹
      if (!file.type.startsWith('video/')) {
        showStatus('âŒ è¯·é€‰æ‹©æœ‰æ•ˆçš„è§†é¢‘æ–‡ä»¶', 'error');
        convertBtn.disabled = true;
        return;
      }
      
      // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ä¸º50MBï¼‰
      if (file.size > 50 * 1024 * 1024) {
        showStatus('âŒ è§†é¢‘æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº50MBçš„æ–‡ä»¶', 'error');
        convertBtn.disabled = true;
        return;
      }
      
      showStatus('ğŸ“¹ æ­£åœ¨åŠ è½½è§†é¢‘...');
      const videoUrl = URL.createObjectURL(file);
      video.src = videoUrl;
      
      video.onloadedmetadata = () => {
        if (video.videoWidth > 0 && video.videoHeight > 0) {
          showStatus(`âœ… è§†é¢‘å·²åŠ è½½ï¼š${video.videoWidth}Ã—${video.videoHeight}ï¼Œæ—¶é•¿${video.duration.toFixed(1)}ç§’`, 'success');
          convertBtn.disabled = false;
        } else {
          showStatus('âŒ è§†é¢‘æ ¼å¼ä¸æ”¯æŒæˆ–æ–‡ä»¶æŸå', 'error');
          convertBtn.disabled = true;
        }
      };
      
      video.onerror = () => {
        showStatus('âŒ è§†é¢‘åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼', 'error');
        convertBtn.disabled = true;
        URL.revokeObjectURL(videoUrl);
      };
    });

    // ç”ŸæˆGIFæ ¸å¿ƒé€»è¾‘
    async function startConvert() {
      try {
        convertBtn.disabled = true;
        
        // å‚æ•°éªŒè¯
        const duration = parseInt(durationInput.value);
        const fps = parseInt(fpsInput.value);
        const scale = parseFloat(scaleInput.value);
        
        if (isNaN(duration) || duration <= 0 || duration > 20) {
          throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„æˆªå–æ—¶é•¿ï¼ˆ1-20ç§’ï¼‰');
        }
        
        if (isNaN(fps) || fps <= 2 || fps > 15) {
          throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„å¸§ç‡ï¼ˆ3-15fpsï¼‰');
        }
        
        if (isNaN(scale) || scale <= 0.1 || scale > 1) {
          throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„ç¼©æ”¾æ¯”ä¾‹ï¼ˆ0.2-1.0ï¼‰');
        }
        
        const totalFrames = duration * fps;
        const frameStep = 1 / fps;

        // æ£€æŸ¥è§†é¢‘çŠ¶æ€
        if (!video.src || video.duration === 0 || isNaN(video.duration)) {
          throw new Error('è§†é¢‘æœªæ­£ç¡®åŠ è½½ï¼Œè¯·é‡æ–°é€‰æ‹©æ–‡ä»¶');
        }
        
        if (video.videoWidth === 0 || video.videoHeight === 0) {
          throw new Error('è§†é¢‘å°ºå¯¸æ— æ•ˆï¼Œè¯·æ£€æŸ¥è§†é¢‘æ–‡ä»¶');
        }

        if (totalFrames > 150) {
          throw new Error('å¸§æ•°è¿‡å¤šï¼Œè¯·å‡å°æ—¶é•¿æˆ–å¸§ç‡ï¼ˆæœ€å¤§150å¸§ï¼‰');
        }

        // è®¾ç½®Canvaså°ºå¯¸
        const canvasWidth = Math.floor(video.videoWidth * scale);
        const canvasHeight = Math.floor(video.videoHeight * scale);
        
        if (canvasWidth <= 0 || canvasHeight <= 0) {
          throw new Error('è®¡ç®—åçš„å°ºå¯¸æ— æ•ˆï¼Œè¯·è°ƒæ•´ç¼©æ”¾æ¯”ä¾‹');
        }
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        showStatus(`ğŸ¬ æ­£åœ¨æ•è·å¸§...ï¼ˆ0/${totalFrames}ï¼‰`);
        gifResult.querySelector('.gif-preview').innerHTML = '';

        // å­˜å‚¨æ‰€æœ‰å¸§çš„å›¾åƒæ•°æ®
        const frames = [];

        // é€å¸§æ•è·è§†é¢‘ç”»é¢
        for (let i = 0; i < totalFrames; i++) {
          // æ¯”è§†é¢‘æ€»æ—¶é•¿ç•¥å°0.1ç§’ï¼Œé˜²æ­¢å–åˆ°è§†é¢‘çš„æœ€åä¸€å¸§æ—¶å‡ºç°è¶Šç•Œæˆ–ç©ºç™½ã€‚
          const currentTime = Math.min(i * frameStep, video.duration - 0.1);
          video.currentTime = currentTime;

          // ç­‰å¾…è§†é¢‘å‡†å¤‡å°±ç»ª
          await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              reject(new Error('è§†é¢‘å¸§åŠ è½½è¶…æ—¶'));
            }, 3000);
            
            const checkFrame = () => {
              if (video.readyState >= 2) {
                clearTimeout(timeout);
                setTimeout(resolve, 50); // ç­‰å¾…50msç¡®ä¿å¸§å®Œå…¨åŠ è½½
              } else {
                requestAnimationFrame(checkFrame);
              }
            };
            checkFrame();
          });

          // ç»˜åˆ¶å½“å‰å¸§åˆ°Canvas
          ctx.drawImage(
            video,
            0, 0, video.videoWidth, video.videoHeight,
            0, 0, canvas.width, canvas.height
          );

          // è·å–å›¾åƒæ•°æ®
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          frames.push(imageData);
          
          showStatus(`ğŸ¬ æ­£åœ¨æ•è·å¸§...ï¼ˆ${i+1}/${totalFrames}ï¼‰`);
        }

        if (frames.length === 0) {
          throw new Error('æ²¡æœ‰æˆåŠŸæ•è·ä»»ä½•å¸§');
        }

        showStatus('ğŸ”„ æ­£åœ¨ç”ŸæˆGIFæ–‡ä»¶...');

        // ä½¿ç”¨æœ¬åœ°GIFç”Ÿæˆç®—æ³•
        const gifBuffer = await createLocalGif(frames, fps);
        const gifBlob = new Blob([gifBuffer], { type: 'image/gif' });
        const gifUrl = URL.createObjectURL(gifBlob);

        // æ˜¾ç¤ºGIF
        const img = new Image();
        img.onload = () => {
          const preview = gifResult.querySelector('.gif-preview');
          preview.innerHTML = '';
          preview.appendChild(img);
          
          // æ·»åŠ ä¸‹è½½æŒ‰é’®
          const downloadBtn = document.createElement('a');
          downloadBtn.href = gifUrl;
          downloadBtn.download = `video-to-gif-${Date.now()}.gif`;
          downloadBtn.textContent = 'ğŸ“¥ ä¸‹è½½GIF';
          downloadBtn.className = 'download-btn';
          preview.appendChild(downloadBtn);
          
          showStatus(`âœ… GIFç”ŸæˆæˆåŠŸï¼å°ºå¯¸ï¼š${canvas.width}Ã—${canvas.height}ï¼Œå¤§å°ï¼š${(gifBlob.size / 1024).toFixed(1)}KBï¼Œ${frames.length}å¸§`, 'success');
        };
        
        img.onerror = () => {
          showStatus('âŒ GIFé¢„è§ˆæ˜¾ç¤ºå¤±è´¥', 'error');
        };
        
        img.src = gifUrl;
        
      } catch (error) {
        console.error('ç”ŸæˆGIFå¤±è´¥:', error);
        showStatus(`âŒ ${error.message}`, 'error');
      } finally {
        convertBtn.disabled = false;
      }
    }

    // æœ¬åœ°GIFç”Ÿæˆç®—æ³•
    async function createLocalGif(frames, fps) {
      const width = frames[0].width;
      const height = frames[0].height;
      const delay = Math.max(Math.round(100 / fps), 4); // å»¶è¿Ÿæ—¶é—´ï¼ˆ1/100ç§’ï¼‰
      
      // åˆ›å»ºè°ƒè‰²æ¿
      const palette = createOptimizedPalette(frames);
      const buffer = [];
      
      // GIFæ–‡ä»¶å¤´
      buffer.push(...stringToBytes('GIF89a'));
      
      // é€»è¾‘å±å¹•æè¿°ç¬¦
      buffer.push(
        width & 0xFF, (width >> 8) & 0xFF,
        height & 0xFF, (height >> 8) & 0xFF,
        0xF7, // å…¨å±€é¢œè‰²è¡¨æ ‡å¿—=1ï¼Œé¢œè‰²åˆ†è¾¨ç‡=7ï¼Œæ’åº=0ï¼Œé¢œè‰²è¡¨å¤§å°=7ï¼ˆ256è‰²ï¼‰
        0, // èƒŒæ™¯é¢œè‰²ç´¢å¼•
        0  // åƒç´ å®½é«˜æ¯”
      );
      
      // å…¨å±€é¢œè‰²è¡¨
      buffer.push(...palette);
      
      // å¾ªç¯æ‰©å±•
      buffer.push(0x21, 0xFF, 0x0B);
      buffer.push(...stringToBytes('NETSCAPE2.0'));
      buffer.push(0x03, 0x01, 0x00, 0x00, 0x00); // æ— é™å¾ªç¯
      
      // å¤„ç†æ¯ä¸€å¸§
      for (let i = 0; i < frames.length; i++) {
        showStatus(`ğŸ”„ æ­£åœ¨å¤„ç†ç¬¬ ${i + 1}/${frames.length} å¸§...`);
        
        // å›¾å½¢æ§åˆ¶æ‰©å±•
        buffer.push(0x21, 0xF9, 0x04, 0x00);
        buffer.push(delay & 0xFF, (delay >> 8) & 0xFF);
        buffer.push(0x00, 0x00); // é€æ˜è‰²ç´¢å¼•ï¼Œå—ç»ˆæ­¢ç¬¦
        
        // å›¾åƒæè¿°ç¬¦
        buffer.push(0x2C);
        buffer.push(0x00, 0x00, 0x00, 0x00); // å·¦ä¸Šè§’ä½ç½®
        buffer.push(width & 0xFF, (width >> 8) & 0xFF);
        buffer.push(height & 0xFF, (height >> 8) & 0xFF);
        buffer.push(0x00); // å±€éƒ¨é¢œè‰²è¡¨æ ‡å¿—
        
        // è½¬æ¢å›¾åƒæ•°æ®
        const indexedData = convertToIndexed(frames[i], palette);
        const compressedData = compressLZW(indexedData);
        
        // è¾“å‡ºå‹ç¼©æ•°æ®
        buffer.push(8); // LZWæœ€å°ä»£ç å¤§å°
        let pos = 0;
        while (pos < compressedData.length) {
          const blockSize = Math.min(255, compressedData.length - pos);
          buffer.push(blockSize);
          for (let j = 0; j < blockSize; j++) {
            buffer.push(compressedData[pos + j]);
          }
          pos += blockSize;
        }
        buffer.push(0); // å—ç»ˆæ­¢ç¬¦
        
        // è®©æµè§ˆå™¨æœ‰æ—¶é—´æ›´æ–°UI
        if (i % 3 === 0) {
          await new Promise(resolve => setTimeout(resolve, 1));
        }
      }
      
      // GIFç»“æŸæ ‡è®°
      buffer.push(0x3B);
      
      return new Uint8Array(buffer);
    }

    // åˆ›å»ºä¼˜åŒ–çš„è°ƒè‰²æ¿
    function createOptimizedPalette(frames) {
      const colorMap = new Map();
      
      // ç»Ÿè®¡æ‰€æœ‰é¢œè‰²ä½¿ç”¨é¢‘ç‡
      frames.forEach(frame => {
        const pixels = frame.data;
        for (let i = 0; i < pixels.length; i += 4) {
          const r = pixels[i] & 0xF8; // é‡åŒ–åˆ°5ä½
          const g = pixels[i + 1] & 0xF8;
          const b = pixels[i + 2] & 0xF8;
          const color = `${r},${g},${b}`;
          colorMap.set(color, (colorMap.get(color) || 0) + 1);
        }
      });
      
      // é€‰æ‹©æœ€å¸¸ç”¨çš„256ç§é¢œè‰²
      const sortedColors = Array.from(colorMap.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 256)
        .map(([color]) => color.split(',').map(Number));
      
      // æ„å»ºè°ƒè‰²æ¿
      const palette = [];
      sortedColors.forEach(([r, g, b]) => {
        palette.push(r, g, b);
      });
      
      // å¡«å……åˆ°256è‰²
      while (palette.length < 768) {
        palette.push(0, 0, 0);
      }
      
      return palette;
    }

    // å°†å›¾åƒè½¬æ¢ä¸ºç´¢å¼•é¢œè‰²
    function convertToIndexed(frame, palette) {
      const pixels = frame.data;
      const indexed = [];
      const paletteMap = new Map();
      
      // æ„å»ºè°ƒè‰²æ¿æ˜ å°„
      for (let i = 0; i < palette.length; i += 3) {
        const color = `${palette[i]},${palette[i + 1]},${palette[i + 2]}`;
        paletteMap.set(color, i / 3);
      }
      
      // è½¬æ¢æ¯ä¸ªåƒç´ 
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i] & 0xF8;
        const g = pixels[i + 1] & 0xF8;
        const b = pixels[i + 2] & 0xF8;
        const color = `${r},${g},${b}`;
        
        let index = paletteMap.get(color);
        if (index === undefined) {
          // æ‰¾æœ€è¿‘ä¼¼çš„é¢œè‰²
          let minDist = Infinity;
          let bestIndex = 0;
          
          for (let j = 0; j < palette.length; j += 3) {
            const dr = r - palette[j];
            const dg = g - palette[j + 1];
            const db = b - palette[j + 2];
            const dist = dr * dr + dg * dg + db * db;
            
            if (dist < minDist) {
              minDist = dist;
              bestIndex = j / 3;
            }
          }
          
          index = bestIndex;
          paletteMap.set(color, index);
        }
        
        indexed.push(index);
      }
      
      return indexed;
    }

    // LZWå‹ç¼©
    function compressLZW(data) {
      const clearCode = 256;
      const endCode = 257;
      let nextCode = 258;
      let codeSize = 9;
      
      const dictionary = new Map();
      const result = [];
      let bitBuffer = 0;
      let bitCount = 0;
      
      // åˆå§‹åŒ–å­—å…¸
      for (let i = 0; i < 256; i++) {
        dictionary.set(i.toString(), i);
      }
      
      function outputCode(code) {
        bitBuffer |= code << bitCount;
        bitCount += codeSize;
        
        while (bitCount >= 8) {
          result.push(bitBuffer & 0xFF);
          bitBuffer >>= 8;
          bitCount -= 8;
        }
      }
      
      outputCode(clearCode);
      
      let w = data[0].toString();
      for (let i = 1; i < data.length; i++) {
        const k = data[i].toString();
        const wk = w + ',' + k;
        
        if (dictionary.has(wk)) {
          w = wk;
        } else {
          outputCode(dictionary.get(w));
          
          if (nextCode < 4096) {
            dictionary.set(wk, nextCode++);
            if (nextCode > (1 << codeSize) && codeSize < 12) {
              codeSize++;
            }
          }
          
          w = k;
        }
      }
      
      outputCode(dictionary.get(w));
      outputCode(endCode);
      
      // è¾“å‡ºå‰©ä½™ä½
      if (bitCount > 0) {
        result.push(bitBuffer & 0xFF);
      }
      
      return result;
    }

    // å­—ç¬¦ä¸²è½¬å­—èŠ‚æ•°ç»„
    function stringToBytes(str) {
      return Array.from(str).map(c => c.charCodeAt(0));
    }

    // é¡µé¢åŠ è½½å®Œæˆæç¤º
    window.addEventListener('load', function() {
      setTimeout(() => {
        showStatus('âœ… æœ¬åœ°GIFç”Ÿæˆå™¨å·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹ä½¿ç”¨', 'success');
      }, 500);
    });

    // æµ‹è¯•GIFåŠŸèƒ½
    async function testGif() {
      try {
        showStatus('ğŸ§ª æ­£åœ¨ç”Ÿæˆæµ‹è¯•GIF...');
        
        // åˆ›å»ºæµ‹è¯•å¸§
        const testFrames = [];
        for (let i = 0; i < 5; i++) {
          const testCanvas = document.createElement('canvas');
          testCanvas.width = 100;
          testCanvas.height = 100;
          const testCtx = testCanvas.getContext('2d');
          
          // ç»˜åˆ¶èƒŒæ™¯
          testCtx.fillStyle = '#f0f0f0';
          testCtx.fillRect(0, 0, 100, 100);
          
          // ç»˜åˆ¶ç§»åŠ¨çš„åœ†
          testCtx.fillStyle = `hsl(${i * 60}, 70%, 50%)`;
          testCtx.beginPath();
          testCtx.arc(20 + i * 15, 50, 15, 0, 2 * Math.PI);
          testCtx.fill();
          
          // æ·»åŠ æ–‡å­—
          testCtx.fillStyle = '#333';
          testCtx.font = '12px Arial';
          testCtx.textAlign = 'center';
          testCtx.fillText(`${i + 1}`, 50, 80);
          
          // è·å–å›¾åƒæ•°æ®
          const imageData = testCtx.getImageData(0, 0, 100, 100);
          testFrames.push(imageData);
        }
        
        // ç”Ÿæˆæµ‹è¯•GIF
        const gifBuffer = await createLocalGif(testFrames, 5);
        const gifBlob = new Blob([gifBuffer], { type: 'image/gif' });
        const gifUrl = URL.createObjectURL(gifBlob);
        
        // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
        const img = new Image();
        img.onload = () => {
          const preview = gifResult.querySelector('.gif-preview');
          preview.innerHTML = '<h4>âœ… æµ‹è¯•GIF</h4>';
          preview.appendChild(img);
          
          const downloadBtn = document.createElement('a');
          downloadBtn.href = gifUrl;
          downloadBtn.download = 'test.gif';
          downloadBtn.textContent = 'ğŸ“¥ ä¸‹è½½æµ‹è¯•GIF';
          downloadBtn.className = 'download-btn';
          preview.appendChild(downloadBtn);
          
          showStatus(`âœ… æµ‹è¯•æˆåŠŸï¼GIFåŠŸèƒ½æ­£å¸¸å·¥ä½œï¼ˆ${(gifBlob.size / 1024).toFixed(1)}KBï¼‰`, 'success');
        };
        
        img.onerror = () => {
          showStatus('âŒ æµ‹è¯•GIFæ˜¾ç¤ºå¤±è´¥', 'error');
        };
        
        img.src = gifUrl;
        
      } catch (error) {
        console.error('æµ‹è¯•å¤±è´¥:', error);
        showStatus(`âŒ æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
      }
    }
  </script>
</body>
</html>