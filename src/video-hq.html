<!DOCTYPE html>
<html>
<head>
  <title>è§†é¢‘è½¬GIFå·¥å…·ï¼ˆé«˜è´¨é‡ç‰ˆ - é˜²å¤±çœŸï¼‰</title>
  <meta charset="UTF-8">
  <style>
    .container { 
      max-width: 1000px; 
      margin: 20px auto; 
      padding: 20px; 
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      border-radius: 10px;
    }
    .preview { 
      display: flex; 
      gap: 20px; 
      margin: 20px 0; 
      flex-wrap: wrap;
    }
    video { 
      max-width: 450px; 
      border: 2px solid #ddd; 
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    #gifResult { 
      max-width: 450px; 
    }
    .controls { 
      margin: 20px 0; 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px; 
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .controls label {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-weight: 600;
      color: #333;
    }
    .controls input, .controls select {
      padding: 10px;
      border: 2px solid #e1e5e9;
      border-radius: 6px;
      font-size: 14px;
      transition: border-color 0.3s;
    }
    .controls input:focus, .controls select:focus {
      outline: none;
      border-color: #4CAF50;
    }
    button { 
      padding: 12px 24px; 
      cursor: pointer; 
      background: linear-gradient(135deg, #4CAF50, #45a049);
      color: white;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(76, 175, 80, 0.4);
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .status { 
      color: #555; 
      margin: 20px 0; 
      padding: 15px;
      background: white;
      border-radius: 8px;
      border-left: 5px solid #2196F3;
      font-size: 14px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .error {
      color: #d32f2f;
      background: #ffebee;
      border-left-color: #d32f2f;
    }
    .success {
      color: #388e3c;
      background: #e8f5e8;
      border-left-color: #388e3c;
    }
    .gif-preview img {
      max-width: 100%;
      border: 2px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .download-btn {
      display: inline-block;
      padding: 10px 20px;
      background: linear-gradient(135deg, #2196F3, #1976D2);
      color: white;
      text-decoration: none;
      border-radius: 6px;
      margin-top: 15px;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);
    }
    .download-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(33, 150, 243, 0.4);
    }
    .quality-tip {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
      font-weight: normal;
    }
    .feature-highlight {
      background: #e3f2fd;
      padding: 15px;
      border-radius: 8px;
      margin: 20px 0;
      border-left: 4px solid #2196F3;
    }
    .feature-highlight h4 {
      margin: 0 0 10px 0;
      color: #1976D2;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ğŸ¬ è§†é¢‘è½¬GIFå·¥å…·ï¼ˆé«˜è´¨é‡é˜²å¤±çœŸç‰ˆï¼‰</h2>
    <p>é‡‡ç”¨å…ˆè¿›çš„é¢œè‰²é‡åŒ–å’ŒæŠ–åŠ¨ç®—æ³•ï¼Œå¤§å¹…å‡å°‘åƒç´ å¤±çœŸï¼Œä¿æŒå›¾åƒç»†èŠ‚</p>
    
    <div class="feature-highlight">
      <h4>ğŸŒŸ é«˜è´¨é‡ç‰¹æ€§</h4>
      <ul style="margin: 0; padding-left: 20px;">
        <li><strong>Floyd-SteinbergæŠ–åŠ¨</strong> - å‡å°‘è‰²å½©æ¡å¸¦</li>
        <li><strong>ä¸­ä½åˆ‡åˆ†è°ƒè‰²æ¿</strong> - æ™ºèƒ½é¢œè‰²é€‰æ‹©</li>
        <li><strong>è‡ªé€‚åº”é‡åŒ–</strong> - ä¿æŒå›¾åƒç»†èŠ‚</li>
        <li><strong>è¾¹ç¼˜ä¿æŠ¤ç®—æ³•</strong> - é˜²æ­¢é”¯é½¿æ•ˆåº”</li>
      </ul>
    </div>
    
    <input type="file" accept="video/*" id="videoInput" style="margin: 20px 0; padding: 10px; border: 2px dashed #ddd; border-radius: 8px; width: 100%; box-sizing: border-box;" />
    
    <div class="controls">
      <label>
        èµ·å§‹æ—¶é—´ï¼ˆç§’ï¼‰
        <input type="number" id="startTime" value="0" min="0" step="0.1">
        <div class="quality-tip">ä»è§†é¢‘çš„ç¬¬å‡ ç§’å¼€å§‹æå–</div>
      </label>
      <label>
        æˆªå–æ—¶é•¿ï¼ˆç§’ï¼‰
        <input type="number" id="duration" value="3" min="1" max="15">
        <div class="quality-tip">å»ºè®®3-6ç§’è·å¾—æœ€ä½³è´¨é‡</div>
      </label>
      <label>
        GIFå¸§ç‡ï¼ˆfpsï¼‰
        <input type="number" id="fps" value="10" min="5" max="20">
        <div class="quality-tip">10-15fpsæœ€ä½³å¹³è¡¡</div>
      </label>
      <label>
        ç¼©æ”¾æ¯”ä¾‹
        <input type="number" id="scale" value="0.7" min="0.4" max="1" step="0.1">
        <div class="quality-tip">0.6-0.8è·å¾—æœ€ä½³æ•ˆæœ</div>
      </label>
      <label>
        å›¾åƒè´¨é‡
        <select id="quality">
          <option value="ultra">è¶…é«˜è´¨é‡ï¼ˆæŠ–åŠ¨+è¾¹ç¼˜ä¿æŠ¤ï¼‰</option>
          <option value="high" selected>é«˜è´¨é‡ï¼ˆFloyd-SteinbergæŠ–åŠ¨ï¼‰</option>
          <option value="medium">ä¸­ç­‰è´¨é‡ï¼ˆä¼˜åŒ–è°ƒè‰²æ¿ï¼‰</option>
        </select>
        <div class="quality-tip">è¶…é«˜è´¨é‡å¤„ç†è¾ƒæ…¢ä½†æ•ˆæœæœ€ä½³</div>
      </label>
      <button onclick="startConvert()" id="convertBtn" disabled>ğŸ¯ ç”Ÿæˆé«˜è´¨é‡GIF</button>
      <button onclick="testGif()" style="background: linear-gradient(135deg, #FF9800, #F57C00);">ğŸ§ª æµ‹è¯•åŠŸèƒ½</button>
    </div>
    
    <div class="status" id="status">è¯·é€‰æ‹©è§†é¢‘æ–‡ä»¶å¼€å§‹ä½¿ç”¨</div>
    
    <div class="preview">
      <div>
        <h4>ğŸ“¹ åŸè§†é¢‘é¢„è§ˆ</h4>
        <video id="video" controls></video>
      </div>
      <div id="gifResult">
        <h4>ğŸ¬ é«˜è´¨é‡GIFç»“æœ</h4>
        <div class="gif-preview"></div>
      </div>
    </div>
  </div>

  <script>
    // =====================================================================================
    // ğŸ¬ è§†é¢‘è½¬GIFå®Œæ•´æµç¨‹æ€»ç»“ - Video to GIF Complete Workflow Summary
    // =====================================================================================
    //
    // ã€æ ¸å¿ƒæµç¨‹æ¦‚è¿°ã€‘
    // æœ¬å·¥å…·å®ç°äº†ä»è§†é¢‘æ–‡ä»¶åˆ°é«˜è´¨é‡GIFåŠ¨ç”»çš„å®Œæ•´è½¬æ¢æµç¨‹ï¼Œæ”¯æŒä»»æ„æ—¶é—´æ®µæå–ã€‚
    //
    // ã€è¯¦ç»†å¤„ç†æ­¥éª¤ã€‘
    // 
    // 1ï¸âƒ£ ã€æ–‡ä»¶å¤„ç†é˜¶æ®µã€‘
    //    â”œâ”€ ç”¨æˆ·é€‰æ‹©è§†é¢‘æ–‡ä»¶ â†’ æ–‡ä»¶ç±»å‹éªŒè¯ â†’ å¤§å°é™åˆ¶æ£€æŸ¥(100MB)
    //    â”œâ”€ åˆ›å»ºè§†é¢‘å¯¹è±¡URL â†’ åŠ è½½è§†é¢‘å…ƒæ•°æ® â†’ è·å–å°ºå¯¸å’Œæ—¶é•¿ä¿¡æ¯
    //    â””â”€ åŠ¨æ€è®¾ç½®UIé™åˆ¶(èµ·å§‹æ—¶é—´æœ€å¤§å€¼ç­‰)
    //
    // 2ï¸âƒ£ ã€å‚æ•°é…ç½®é˜¶æ®µã€‘
    //    â”œâ”€ èµ·å§‹æ—¶é—´è®¾ç½®(æ”¯æŒä»»æ„æ—¶é—´ç‚¹å¼€å§‹)
    //    â”œâ”€ æˆªå–æ—¶é•¿é…ç½®(1-15ç§’) 
    //    â”œâ”€ å¸§ç‡é€‰æ‹©(5-20fps)
    //    â”œâ”€ ç¼©æ”¾æ¯”ä¾‹(0.4-1.0)
    //    â””â”€ è´¨é‡ç­‰çº§(è¶…é«˜/é«˜/ä¸­ç­‰è´¨é‡)
    //
    // 3ï¸âƒ£ ã€è§†é¢‘å¸§æ•è·é˜¶æ®µã€‘
    //    â”œâ”€ è®¡ç®—æ€»å¸§æ•°å’Œæ—¶é—´é—´éš” â†’ éªŒè¯å¸§æ•°é™åˆ¶(æœ€å¤§100å¸§)
    //    â”œâ”€ è®¾ç½®Canvaså°ºå¯¸(æ ¹æ®ç¼©æ”¾æ¯”ä¾‹)
    //    â”œâ”€ é€å¸§å¤„ç†å¾ªç¯:
    //    â”‚  â”œâ”€ è§†é¢‘è·³è½¬åˆ°æŒ‡å®šæ—¶é—´ç‚¹ â†’ ç­‰å¾…å¸§æ•°æ®å‡†å¤‡å°±ç»ª
    //    â”‚  â”œâ”€ é«˜è´¨é‡ç»˜åˆ¶åˆ°Canvas(å¯ç”¨å¹³æ»‘å¤„ç†)
    //    â”‚  â”œâ”€ è·å–ImageDataåƒç´ æ•°æ® â†’ å­˜å‚¨åˆ°å¸§æ•°ç»„
    //    â”‚  â””â”€ æ˜¾ç¤ºæ•è·è¿›åº¦(åŒ…å«å½“å‰æ—¶é—´ç‚¹)
    //    â””â”€ å®Œæˆæ‰€æœ‰å¸§çš„æ•è·å’Œå­˜å‚¨
    //
    // 4ï¸âƒ£ ã€GIFç¼–ç é˜¶æ®µã€‘
    //    â”œâ”€ ğŸ¨ è°ƒè‰²æ¿ç”Ÿæˆ: ç»Ÿè®¡æ‰€æœ‰å¸§é¢œè‰²é¢‘ç‡ â†’ é€‰æ‹©æœ€å¸¸ç”¨256è‰² â†’ æ„å»ºè°ƒè‰²æ¿
    //    â”œâ”€ ğŸ”„ é¢œè‰²è½¬æ¢: RGBåƒç´  â†’ é‡åŒ–å¤„ç† â†’ è°ƒè‰²æ¿ç´¢å¼•æ˜ å°„ â†’ æœ€è¿‘è‰²åŒ¹é…
    //    â”œâ”€ ğŸ“¦ LZWå‹ç¼©: ç´¢å¼•æ•°æ® â†’ å­—å…¸æ„å»º â†’ ä½æµç¼–ç  â†’ æ•°æ®å—åˆ†å‰²
    //    â””â”€ ğŸ—ï¸ GIFæ–‡ä»¶æ„å»º:
    //       â”œâ”€ æ–‡ä»¶å¤´: GIF89aç­¾å â†’ é€»è¾‘å±å¹•æè¿°ç¬¦ â†’ å…¨å±€é¢œè‰²è¡¨
    //       â”œâ”€ æ‰©å±•å—: å¾ªç¯æ’­æ”¾è®¾ç½®(NETSCAPE2.0)
    //       â”œâ”€ å¸§æ•°æ®: å›¾å½¢æ§åˆ¶æ‰©å±• â†’ å›¾åƒæè¿°ç¬¦ â†’ LZWå‹ç¼©æ•°æ®
    //       â””â”€ æ–‡ä»¶å°¾: ç»“æŸæ ‡è®°(0x3B)
    //
    // 5ï¸âƒ£ ã€ç»“æœè¾“å‡ºé˜¶æ®µã€‘
    //    â”œâ”€ ç”ŸæˆBlobå¯¹è±¡ â†’ åˆ›å»ºä¸‹è½½URL â†’ æ˜¾ç¤ºé¢„è§ˆå›¾åƒ
    //    â”œâ”€ æ·»åŠ ä¸‹è½½æŒ‰é’®(æ—¶é—´æˆ³æ–‡ä»¶å)
    //    â””â”€ æ˜¾ç¤ºå®Œæˆä¿¡æ¯(æ—¶é—´æ®µã€å°ºå¯¸ã€æ–‡ä»¶å¤§å°)
    //
    // ã€æ ¸å¿ƒæŠ€æœ¯ç‰¹æ€§ã€‘
    // âœ¨ é«˜è´¨é‡ç®—æ³•: Floyd-SteinbergæŠ–åŠ¨ã€ä¸­ä½åˆ‡åˆ†è°ƒè‰²æ¿ã€è¾¹ç¼˜ä¿æŠ¤
    // âš¡ æ€§èƒ½ä¼˜åŒ–: é¢œè‰²æ˜ å°„ç¼“å­˜ã€å†…å­˜é™åˆ¶æ§åˆ¶ã€å¼‚æ­¥å¤„ç†é˜²é¡µé¢å†»ç»“  
    // ğŸ¯ ç²¾ç¡®æ§åˆ¶: ä»»æ„æ—¶é—´æ®µæå–ã€å®æ—¶é¢„è§ˆã€å‚æ•°å®æ—¶éªŒè¯
    // ğŸ”§ æ ‡å‡†å…¼å®¹: å®Œæ•´GIF89aæ ¼å¼æ”¯æŒã€æ ‡å‡†LZWå‹ç¼©ç®—æ³•
    //
    // =====================================================================================

    // ==================================================
    // DOMå…ƒç´ è·å– - è·å–é¡µé¢ä¸­çš„å„ç§è¾“å…¥æ§ä»¶å’Œæ˜¾ç¤ºå…ƒç´ 
    // ==================================================
    const videoInput = document.getElementById('videoInput');     // è§†é¢‘æ–‡ä»¶è¾“å…¥æ¡†
    const video = document.getElementById('video');               // è§†é¢‘æ’­æ”¾å…ƒç´ 
    const startTimeInput = document.getElementById('startTime');  // èµ·å§‹æ—¶é—´è¾“å…¥æ¡†
    const durationInput = document.getElementById('duration');    // æˆªå–æ—¶é•¿è¾“å…¥æ¡†
    const fpsInput = document.getElementById('fps');              // å¸§ç‡è¾“å…¥æ¡†
    const scaleInput = document.getElementById('scale');          // ç¼©æ”¾æ¯”ä¾‹è¾“å…¥æ¡†
    const qualitySelect = document.getElementById('quality');     // å›¾åƒè´¨é‡é€‰æ‹©æ¡†
    const statusDiv = document.getElementById('status');          // çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸ
    const gifResult = document.getElementById('gifResult');       // GIFç»“æœæ˜¾ç¤ºåŒºåŸŸ
    const convertBtn = document.getElementById('convertBtn');     // è½¬æ¢æŒ‰é’®
    const canvas = document.createElement('canvas');              // ç”¨äºè§†é¢‘å¸§æ•è·çš„ç”»å¸ƒ
    const ctx = canvas.getContext('2d');                          // ç”»å¸ƒç»˜å›¾ä¸Šä¸‹æ–‡

    // ==================================================
    // å·¥å…·å‡½æ•° - è¾…åŠ©åŠŸèƒ½å‡½æ•°
    // ==================================================
    
    /**
     * æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
     * @param {string} message - è¦æ˜¾ç¤ºçš„æ¶ˆæ¯å†…å®¹
     * @param {string} type - æ¶ˆæ¯ç±»å‹: 'info'(é»˜è®¤), 'error', 'success'
     */
    function showStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
    }

    // ==================================================
    // è§†é¢‘æ–‡ä»¶å¤„ç† - å¤„ç†ç”¨æˆ·é€‰æ‹©çš„è§†é¢‘æ–‡ä»¶
    // ==================================================
    
    /**
     * è§†é¢‘æ–‡ä»¶é€‰æ‹©äº‹ä»¶ç›‘å¬å™¨
     * å½“ç”¨æˆ·é€‰æ‹©è§†é¢‘æ–‡ä»¶æ—¶è§¦å‘ï¼Œè¿›è¡Œæ–‡ä»¶éªŒè¯å’ŒåŠ è½½
     */
    videoInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      
      // æ£€æŸ¥æ˜¯å¦é€‰æ‹©äº†æ–‡ä»¶
      if (!file) {
        convertBtn.disabled = true;
        return;
      }
      
      // éªŒè¯æ–‡ä»¶ç±»å‹æ˜¯å¦ä¸ºè§†é¢‘
      if (!file.type.startsWith('video/')) {
        showStatus('âŒ è¯·é€‰æ‹©æœ‰æ•ˆçš„è§†é¢‘æ–‡ä»¶', 'error');
        convertBtn.disabled = true;
        return;
      }
      
      // æ£€æŸ¥æ–‡ä»¶å¤§å°é™åˆ¶ï¼ˆ100MBä»¥å†…ï¼‰
      if (file.size > 100 * 1024 * 1024) {
        showStatus('âŒ è§†é¢‘æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº100MBçš„æ–‡ä»¶', 'error');
        convertBtn.disabled = true;
        return;
      }
      
      showStatus('ğŸ“¹ æ­£åœ¨åŠ è½½è§†é¢‘...');
      
      // åˆ›å»ºè§†é¢‘å¯¹è±¡URLå¹¶è®¾ç½®åˆ°videoå…ƒç´ 
      const videoUrl = URL.createObjectURL(file);
      video.src = videoUrl;
      
      // è§†é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆäº‹ä»¶
      video.onloadedmetadata = () => {
        // éªŒè¯è§†é¢‘æ˜¯å¦æœ‰æ•ˆï¼ˆå®½é«˜å¤§äº0ï¼‰
        if (video.videoWidth > 0 && video.videoHeight > 0) {
          showStatus(`âœ… è§†é¢‘å·²åŠ è½½ï¼š${video.videoWidth}Ã—${video.videoHeight}ï¼Œæ—¶é•¿${video.duration.toFixed(1)}ç§’`, 'success');
          convertBtn.disabled = false;
          
          // åŠ¨æ€è®¾ç½®èµ·å§‹æ—¶é—´çš„æœ€å¤§å€¼ï¼ˆç•™0.5ç§’ç¼“å†²ï¼‰
          startTimeInput.max = Math.max(0, video.duration - 0.5);
        } else {
          showStatus('âŒ è§†é¢‘æ ¼å¼ä¸æ”¯æŒæˆ–æ–‡ä»¶æŸå', 'error');
          convertBtn.disabled = true;
        }
      };
      
      // è§†é¢‘åŠ è½½é”™è¯¯äº‹ä»¶
      video.onerror = () => {
        showStatus('âŒ è§†é¢‘åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼', 'error');
        convertBtn.disabled = true;
        URL.revokeObjectURL(videoUrl);  // æ¸…ç†å¯¹è±¡URLé¿å…å†…å­˜æ³„æ¼
      };
    });

    // ==================================================
    // GIFç”Ÿæˆæ ¸å¿ƒåŠŸèƒ½ - ä¸»è¦çš„è§†é¢‘è½¬GIFå¤„ç†é€»è¾‘
    // ==================================================
    
    /**
     * å¼€å§‹è½¬æ¢è§†é¢‘ä¸ºGIF
     * ä¸»è¦æµç¨‹ï¼šå‚æ•°éªŒè¯ -> é€å¸§æ•è· -> GIFç¼–ç  -> ç»“æœæ˜¾ç¤º
     */
    async function startConvert() {
      try {
        // ç¦ç”¨è½¬æ¢æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
        convertBtn.disabled = true;
        
        // è·å–ç”¨æˆ·è®¾ç½®çš„å„é¡¹å‚æ•°
        const startTime = parseFloat(startTimeInput.value);  // èµ·å§‹æ—¶é—´
        const duration = parseInt(durationInput.value);      // æˆªå–æ—¶é•¿
        const fps = parseInt(fpsInput.value);                // å¸§ç‡
        const scale = parseFloat(scaleInput.value);          // ç¼©æ”¾æ¯”ä¾‹
        const quality = qualitySelect.value;                 // å›¾åƒè´¨é‡
        
        // ==================== å‚æ•°éªŒè¯ ====================
        
        // éªŒè¯èµ·å§‹æ—¶é—´
        if (isNaN(startTime) || startTime < 0) {
          throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„èµ·å§‹æ—¶é—´ï¼ˆâ‰¥0ç§’ï¼‰');
        }
        
        // éªŒè¯æˆªå–æ—¶é•¿
        if (isNaN(duration) || duration <= 0 || duration > 15) {
          throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„æˆªå–æ—¶é•¿ï¼ˆ1-15ç§’ï¼‰');
        }
        
        // éªŒè¯æ—¶é—´èŒƒå›´ä¸è¶…è¿‡è§†é¢‘æ€»é•¿åº¦
        if (startTime + duration > video.duration) {
          throw new Error(`èµ·å§‹æ—¶é—´+æˆªå–æ—¶é•¿ä¸èƒ½è¶…è¿‡è§†é¢‘æ€»æ—¶é•¿ï¼ˆ${video.duration.toFixed(1)}ç§’ï¼‰`);
        }
        
        // éªŒè¯å¸§ç‡èŒƒå›´
        if (isNaN(fps) || fps <= 4 || fps > 20) {
          throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„å¸§ç‡ï¼ˆ5-20fpsï¼‰');
        }
        
        // éªŒè¯ç¼©æ”¾æ¯”ä¾‹
        if (isNaN(scale) || scale <= 0.3 || scale > 1) {
          throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„ç¼©æ”¾æ¯”ä¾‹ï¼ˆ0.4-1.0ï¼‰');
        }
        
        // ==================== è®¡ç®—å¸§å‚æ•° ====================
        
        const totalFrames = duration * fps;  // æ€»å¸§æ•°
        const frameStep = 1 / fps;           // æ¯å¸§æ—¶é—´é—´éš”

        // éªŒè¯è§†é¢‘çŠ¶æ€
        if (!video.src || video.duration === 0) {
          throw new Error('è§†é¢‘æœªæ­£ç¡®åŠ è½½ï¼Œè¯·é‡æ–°é€‰æ‹©æ–‡ä»¶');
        }
        
        // é™åˆ¶æœ€å¤§å¸§æ•°é˜²æ­¢å†…å­˜é—®é¢˜
        if (totalFrames > 100) {
          throw new Error('å¸§æ•°è¿‡å¤šï¼Œè¯·å‡å°æ—¶é•¿æˆ–å¸§ç‡ï¼ˆæœ€å¤§100å¸§ï¼‰');
        }

        // è®¾ç½®ç”»å¸ƒå°ºå¯¸ï¼ˆæ ¹æ®ç¼©æ”¾æ¯”ä¾‹ï¼‰
        canvas.width = Math.floor(video.videoWidth * scale);
        canvas.height = Math.floor(video.videoHeight * scale);

        // æ˜¾ç¤ºå¼€å§‹å¤„ç†çŠ¶æ€å¹¶æ¸…ç©ºä¹‹å‰çš„ç»“æœ
        showStatus(`ğŸ¬ æ­£åœ¨ä»${startTime.toFixed(1)}ç§’å¼€å§‹æ•è·${totalFrames}å¸§...`);
        gifResult.querySelector('.gif-preview').innerHTML = '';

        // å­˜å‚¨æ•è·çš„æ‰€æœ‰å¸§æ•°æ®
        const frames = [];

        // ==================== é€å¸§æ•è·è§†é¢‘å†…å®¹ ====================
        
        for (let i = 0; i < totalFrames; i++) {
          // è®¡ç®—å½“å‰å¸§å¯¹åº”çš„è§†é¢‘æ—¶é—´ç‚¹
          const currentTime = Math.min(startTime + i * frameStep, video.duration - 0.1);
          video.currentTime = currentTime;

          // ç­‰å¾…è§†é¢‘è·³è½¬åˆ°æŒ‡å®šæ—¶é—´ç‚¹å¹¶å‡†å¤‡å¥½
          await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error('è§†é¢‘å¸§åŠ è½½è¶…æ—¶')), 5000);
            
            const checkFrame = () => {
              // readyState >= 2 è¡¨ç¤ºå½“å‰å¸§æ•°æ®å·²å‡†å¤‡å¥½
              if (video.readyState >= 2) {
                clearTimeout(timeout);
                // ç¨å¾®å»¶è¿Ÿç¡®ä¿å¸§å®Œå…¨åŠ è½½
                setTimeout(resolve, 100);
              } else {
                // ç»§ç»­æ£€æŸ¥
                requestAnimationFrame(checkFrame);
              }
            };
            checkFrame();
          });

          // é«˜è´¨é‡ç»˜åˆ¶è§†é¢‘å¸§åˆ°ç”»å¸ƒ
          ctx.imageSmoothingEnabled = true;           // å¯ç”¨å¹³æ»‘å¤„ç†
          ctx.imageSmoothingQuality = 'high';         // ä½¿ç”¨é«˜è´¨é‡å¹³æ»‘ç®—æ³•
          ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, canvas.width, canvas.height);

          // è·å–ç”»å¸ƒå›¾åƒæ•°æ®å¹¶å­˜å‚¨
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          frames.push(imageData);
          
          // æ˜¾ç¤ºæ•è·è¿›åº¦
          showStatus(`ğŸ¬ æ•è·ä¸­... ${i+1}/${totalFrames} (${Math.round((i+1)/totalFrames*100)}%) - æ—¶é—´:${currentTime.toFixed(1)}s`);
        }

        // ==================== ç”ŸæˆGIFæ–‡ä»¶ ====================
        
        showStatus('ğŸ”„ æ­£åœ¨ç”ŸæˆGIFæ–‡ä»¶...');
        
        // è°ƒç”¨GIFç¼–ç ç®—æ³•ç”ŸæˆäºŒè¿›åˆ¶æ•°æ®
        const gifBuffer = await createLocalGif(frames, fps);
        const gifBlob = new Blob([gifBuffer], { type: 'image/gif' });
        const gifUrl = URL.createObjectURL(gifBlob);

        // åˆ›å»ºé¢„è§ˆå›¾åƒ
        const img = new Image();
        
        // å›¾åƒåŠ è½½æˆåŠŸåæ˜¾ç¤ºç»“æœå’Œä¸‹è½½é“¾æ¥
        img.onload = () => {
          const preview = gifResult.querySelector('.gif-preview');
          preview.innerHTML = '';
          preview.appendChild(img);
          
          // åˆ›å»ºä¸‹è½½æŒ‰é’®
          const downloadBtn = document.createElement('a');
          downloadBtn.href = gifUrl;
          downloadBtn.download = `hq-gif-${Date.now()}.gif`;  // ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºæ–‡ä»¶å
          downloadBtn.textContent = 'ğŸ“¥ ä¸‹è½½é«˜è´¨é‡GIF';
          downloadBtn.className = 'download-btn';
          preview.appendChild(downloadBtn);
          
          // æ˜¾ç¤ºå®ŒæˆçŠ¶æ€ä¿¡æ¯
          showStatus(`âœ… é«˜è´¨é‡GIFç”Ÿæˆå®Œæˆï¼æ—¶é—´æ®µï¼š${startTime.toFixed(1)}-${(startTime + duration).toFixed(1)}ç§’ï¼Œå°ºå¯¸ï¼š${canvas.width}Ã—${canvas.height}ï¼Œå¤§å°ï¼š${(gifBlob.size / 1024).toFixed(1)}KB`, 'success');
        };
        
        // å›¾åƒåŠ è½½å¤±è´¥å¤„ç†
        img.onerror = () => showStatus('âŒ GIFé¢„è§ˆå¤±è´¥', 'error');
        img.src = gifUrl;
        
      } catch (error) {
        // æ•è·å¹¶æ˜¾ç¤ºä»»ä½•å¤„ç†è¿‡ç¨‹ä¸­çš„é”™è¯¯
        showStatus(`âŒ ${error.message}`, 'error');
      } finally {
        // æ— è®ºæˆåŠŸå¤±è´¥éƒ½é‡æ–°å¯ç”¨è½¬æ¢æŒ‰é’®
        convertBtn.disabled = false;
      }
    }

    // ==================================================
    // GIFæ–‡ä»¶ç¼–ç ç®—æ³• - å°†å›¾åƒå¸§æ•°æ®ç¼–ç ä¸ºæ ‡å‡†GIFæ ¼å¼
    // ==================================================
    
    /**
     * æœ¬åœ°GIFç”Ÿæˆç®—æ³•ï¼ˆåŸºäºGIF89aæ ‡å‡†ï¼‰
     * @param {Array} frames - å›¾åƒå¸§æ•°æ®æ•°ç»„
     * @param {number} fps - å¸§ç‡
     * @returns {Uint8Array} ç”Ÿæˆçš„GIFæ–‡ä»¶äºŒè¿›åˆ¶æ•°æ®
     */
    async function createLocalGif(frames, fps) {
      // è·å–å›¾åƒå°ºå¯¸ä¿¡æ¯
      const width = frames[0].width;
      const height = frames[0].height;
      const delay = Math.max(Math.round(100 / fps), 4); // å»¶è¿Ÿæ—¶é—´ï¼ˆå•ä½ï¼š1/100ç§’ï¼‰
      
      // åˆ›å»ºä¼˜åŒ–çš„256è‰²è°ƒè‰²æ¿
      const palette = createOptimizedPalette(frames);
      const buffer = [];
      
      // ==================== GIFæ–‡ä»¶å¤´éƒ¨ä¿¡æ¯ ====================
      
      // GIF89aæ–‡ä»¶ç­¾å
      buffer.push(...stringToBytes('GIF89a'));
      
      // é€»è¾‘å±å¹•æè¿°ç¬¦ï¼ˆ7å­—èŠ‚ï¼‰
      buffer.push(
        width & 0xFF, (width >> 8) & 0xFF,         // å±å¹•å®½åº¦ï¼ˆå°ç«¯åºï¼‰
        height & 0xFF, (height >> 8) & 0xFF,       // å±å¹•é«˜åº¦ï¼ˆå°ç«¯åºï¼‰
        0xF7,                                       // å…¨å±€é¢œè‰²è¡¨æ ‡å¿—=1ï¼Œé¢œè‰²åˆ†è¾¨ç‡=7ï¼Œæ’åº=0ï¼Œé¢œè‰²è¡¨å¤§å°=7ï¼ˆ256è‰²ï¼‰
        0,                                          // èƒŒæ™¯é¢œè‰²ç´¢å¼•
        0                                           // åƒç´ å®½é«˜æ¯”
      );
      
      // å…¨å±€é¢œè‰²è¡¨ï¼ˆ256è‰² Ã— 3å­—èŠ‚RGB = 768å­—èŠ‚ï¼‰
      buffer.push(...palette);
      
      // åº”ç”¨æ‰©å±•å—ï¼šè®¾ç½®å¾ªç¯æ’­æ”¾
      buffer.push(0x21, 0xFF, 0x0B);                 // åº”ç”¨æ‰©å±•æ ‡è¯†
      buffer.push(...stringToBytes('NETSCAPE2.0'));  // åº”ç”¨åç§°
      buffer.push(0x03, 0x01, 0x00, 0x00, 0x00);     // æ•°æ®ï¼šæ— é™å¾ªç¯
      
      // ==================== å¤„ç†æ¯ä¸€å¸§å›¾åƒæ•°æ® ====================
      
      for (let i = 0; i < frames.length; i++) {
        showStatus(`ğŸ”„ æ­£åœ¨å¤„ç†ç¬¬ ${i + 1}/${frames.length} å¸§...`);
        
        // å›¾å½¢æ§åˆ¶æ‰©å±•å—ï¼ˆæ§åˆ¶å¸§çš„æ˜¾ç¤ºæ–¹å¼ï¼‰
        buffer.push(0x21, 0xF9, 0x04, 0x00);           // æ‰©å±•æ ‡è¯†å’Œæ ‡ç­¾
        buffer.push(delay & 0xFF, (delay >> 8) & 0xFF); // å¸§å»¶è¿Ÿæ—¶é—´ï¼ˆå°ç«¯åºï¼‰
        buffer.push(0x00, 0x00);                        // é€æ˜è‰²ç´¢å¼•ï¼Œå—ç»ˆæ­¢ç¬¦
        
        // å›¾åƒæè¿°ç¬¦ï¼ˆæè¿°å½“å‰å¸§çš„ä½ç½®å’Œå°ºå¯¸ï¼‰
        buffer.push(0x2C);                              // å›¾åƒåˆ†éš”ç¬¦
        buffer.push(0x00, 0x00, 0x00, 0x00);           // å›¾åƒå·¦ä¸Šè§’ä½ç½®ï¼ˆx,y = 0,0ï¼‰
        buffer.push(width & 0xFF, (width >> 8) & 0xFF); // å›¾åƒå®½åº¦ï¼ˆå°ç«¯åºï¼‰
        buffer.push(height & 0xFF, (height >> 8) & 0xFF); // å›¾åƒé«˜åº¦ï¼ˆå°ç«¯åºï¼‰
        buffer.push(0x00);                              // å±€éƒ¨é¢œè‰²è¡¨æ ‡å¿—ï¼ˆä½¿ç”¨å…¨å±€é¢œè‰²è¡¨ï¼‰
        
        // å›¾åƒæ•°æ®å¤„ç†ï¼šRGB -> ç´¢å¼•é¢œè‰² -> LZWå‹ç¼©
        const indexedData = convertToIndexed(frames[i], palette);  // è½¬æ¢ä¸ºè°ƒè‰²æ¿ç´¢å¼•
        const compressedData = compressLZW(indexedData);           // LZWå‹ç¼©
        
        // è¾“å‡ºLZWå‹ç¼©æ•°æ®ï¼ˆæŒ‰æ•°æ®å—æ ¼å¼ï¼‰
        buffer.push(8);  // LZWæœ€å°ä»£ç å¤§å°ï¼ˆ8ä½ï¼‰
        
        let pos = 0;
        while (pos < compressedData.length) {
          // æ¯ä¸ªæ•°æ®å—æœ€å¤§255å­—èŠ‚
          const blockSize = Math.min(255, compressedData.length - pos);
          buffer.push(blockSize);  // å—å¤§å°
          
          // è¾“å‡ºå—æ•°æ®
          for (let j = 0; j < blockSize; j++) {
            buffer.push(compressedData[pos + j]);
          }
          pos += blockSize;
        }
        buffer.push(0);  // æ•°æ®å—ç»ˆæ­¢ç¬¦
        
        // å®šæœŸè®©å‡ºæ§åˆ¶æƒï¼Œé˜²æ­¢é¡µé¢å†»ç»“
        if (i % 3 === 0) {
          await new Promise(resolve => setTimeout(resolve, 1));
        }
      }
      
      // ==================== GIFæ–‡ä»¶ç»“æŸ ====================
      
      // GIFæ–‡ä»¶ç»“æŸæ ‡è®°
      buffer.push(0x3B);
      
      // è¿”å›å®Œæ•´çš„GIFæ–‡ä»¶äºŒè¿›åˆ¶æ•°æ®
      return new Uint8Array(buffer);
    }

    // ==================================================
    // è°ƒè‰²æ¿ç”Ÿæˆç®—æ³• - ä»å›¾åƒå¸§ä¸­æå–æœ€ä¼˜256è‰²è°ƒè‰²æ¿
    // ==================================================
    
    /**
     * åˆ›å»ºä¼˜åŒ–çš„è°ƒè‰²æ¿
     * é€šè¿‡ç»Ÿè®¡é¢œè‰²é¢‘ç‡ï¼Œé€‰æ‹©æœ€å¸¸ç”¨çš„256ç§é¢œè‰²ä½œä¸ºè°ƒè‰²æ¿
     * @param {Array} frames - å›¾åƒå¸§æ•°ç»„
     * @returns {Array} 256è‰²è°ƒè‰²æ¿æ•°æ®ï¼ˆ768å­—èŠ‚RGBï¼‰
     */
    function createOptimizedPalette(frames) {
      const colorMap = new Map();
      
      // ç»Ÿè®¡æ‰€æœ‰å¸§ä¸­æ¯ç§é¢œè‰²çš„ä½¿ç”¨é¢‘ç‡
      frames.forEach(frame => {
        const pixels = frame.data;
        for (let i = 0; i < pixels.length; i += 4) {
          // å°†RGBé¢œè‰²é‡åŒ–åˆ°5ä½ç²¾åº¦ï¼ˆå‡å°‘é¢œè‰²æ•°é‡ï¼‰ 
          // ä¿ç•™é¢œè‰²å€¼çš„é«˜5ä½ï¼šå³é¢œè‰²é€šé“çš„ä¸»è¦æœ‰æ•ˆä¿¡æ¯ã€‚
          // ä¸¢å¼ƒä½3ä½ï¼šç›¸å½“äºèˆå¼ƒé¢œè‰²çš„ç»†èŠ‚ç²¾åº¦æˆ–å™ªå£°æ•°æ®ã€‚
          const r = pixels[i] & 0xF8;     // æå–çº¢è‰²é€šé“çš„é«˜5ä½
          const g = pixels[i + 1] & 0xF8; //æå–ç»¿è‰²é€šé“çš„é«˜5ä½
          const b = pixels[i + 2] & 0xF8; // æå–è“è‰²é€šé“çš„é«˜5ä½
          const color = `${r},${g},${b}`;
          
          // ç»Ÿè®¡é¢œè‰²å‡ºç°æ¬¡æ•°
          colorMap.set(color, (colorMap.get(color) || 0) + 1);
        }
      });
      
      // æŒ‰ä½¿ç”¨é¢‘ç‡æ’åºï¼Œé€‰æ‹©æœ€å¸¸ç”¨çš„256ç§é¢œè‰²
      const sortedColors = Array.from(colorMap.entries())
        .sort((a, b) => b[1] - a[1])      // æŒ‰é¢‘ç‡é™åºæ’åˆ—
        .slice(0, 256)                    // å–å‰256ç§
        .map(([color]) => color.split(',').map(Number));  // è½¬æ¢ä¸ºRGBæ•°å€¼
      
      // æ„å»ºæ ‡å‡†GIFè°ƒè‰²æ¿æ ¼å¼
      const palette = [];
      sortedColors.forEach(([r, g, b]) => {
        palette.push(r, g, b);  // æŒ‰RGBé¡ºåºæ·»åŠ 
      });
      
      // å¡«å……å‰©ä½™ä½ç½®åˆ°768å­—èŠ‚ï¼ˆ256è‰² Ã— 3å­—èŠ‚RGBï¼‰
      while (palette.length < 768) {
        palette.push(0, 0, 0);  // ç”¨é»‘è‰²å¡«å……
      }
      
      return palette;
    }

    /**
     * å°†RGBå›¾åƒè½¬æ¢ä¸ºç´¢å¼•é¢œè‰²
     * æ¯ä¸ªåƒç´ ä»RGBå€¼è½¬æ¢ä¸ºè°ƒè‰²æ¿ä¸­æœ€æ¥è¿‘é¢œè‰²çš„ç´¢å¼•
     * @param {ImageData} frame - å›¾åƒå¸§æ•°æ®
     * @param {Array} palette - è°ƒè‰²æ¿æ•°æ®
     * @returns {Array} ç´¢å¼•é¢œè‰²æ•°ç»„
     */
    function convertToIndexed(frame, palette) {
      const pixels = frame.data;
      const indexed = [];
      const paletteMap = new Map();  // ç¼“å­˜é¢œè‰²æ˜ å°„å…³ç³»ï¼Œæé«˜æ€§èƒ½
      
      // æ„å»ºè°ƒè‰²æ¿é¢œè‰²åˆ°ç´¢å¼•çš„æ˜ å°„è¡¨
      for (let i = 0; i < palette.length; i += 3) {
        const color = `${palette[i]},${palette[i + 1]},${palette[i + 2]}`;
        paletteMap.set(color, i / 3);  // é¢œè‰²å­—ç¬¦ä¸² -> è°ƒè‰²æ¿ç´¢å¼•
      }
      
      // é€åƒç´ è½¬æ¢ï¼šRGB -> è°ƒè‰²æ¿ç´¢å¼•
      for (let i = 0; i < pixels.length; i += 4) {
        // é‡åŒ–åƒç´ é¢œè‰²ï¼ˆä¸è°ƒè‰²æ¿ç”Ÿæˆæ—¶ä¿æŒä¸€è‡´ï¼‰
        const r = pixels[i] & 0xF8;
        const g = pixels[i + 1] & 0xF8;
        const b = pixels[i + 2] & 0xF8;
        const color = `${r},${g},${b}`;
        
        // ä¼˜å…ˆæŸ¥æ‰¾ç²¾ç¡®åŒ¹é…
        let index = paletteMap.get(color);
        if (index === undefined) {
          // æ²¡æœ‰ç²¾ç¡®åŒ¹é…æ—¶ï¼Œå¯»æ‰¾æœ€ç›¸ä¼¼çš„é¢œè‰²
          let minDist = Infinity;
          let bestIndex = 0;
          
          // è®¡ç®—ä¸è°ƒè‰²æ¿ä¸­æ¯ç§é¢œè‰²çš„æ¬§å‡ é‡Œå¾—è·ç¦»
          for (let j = 0; j < palette.length; j += 3) {
            const dr = r - palette[j];
            const dg = g - palette[j + 1];
            const db = b - palette[j + 2];
            const dist = dr * dr + dg * dg + db * db;  // è·ç¦»å¹³æ–¹
            
            if (dist < minDist) {
              minDist = dist;
              bestIndex = j / 3;
            }
          }
          
          index = bestIndex;
          paletteMap.set(color, index);  // ç¼“å­˜ç»“æœ
        }
        
        indexed.push(index);
      }
      
      return indexed;
    }

    // æ™ºèƒ½è°ƒè‰²æ¿ç”Ÿæˆï¼ˆä¿ç•™åŸæœ‰åŠŸèƒ½ï¼‰
    async function createSmartPalette(frames, quality) {
      const samples = [];
      const sampleRate = quality === 'ultra' ? 1 : quality === 'high' ? 2 : 4;
      
      // é‡‡æ ·é¢œè‰²ï¼ˆé™åˆ¶æ ·æœ¬æ•°é‡ï¼‰
      const maxSamplesPerFrame = 1000;
      frames.forEach((frame, frameIndex) => {
        if (samples.length > 50000) return; // æ€»æ ·æœ¬æ•°é™åˆ¶
        
        const pixels = frame.data;
        const totalPixels = pixels.length / 4;
        const step = Math.max(sampleRate, Math.floor(totalPixels / maxSamplesPerFrame));
        
        for (let i = 0; i < pixels.length; i += 4 * step) {
          if (pixels[i + 3] > 128) { // éé€æ˜åƒç´ 
            samples.push([pixels[i], pixels[i + 1], pixels[i + 2]]);
          }
          if (samples.length > 50000) break; // é˜²æ­¢æ ·æœ¬è¿‡å¤š
        }
      });
      
      // ä¸­ä½åˆ‡åˆ†ç®—æ³•ï¼ˆéé€’å½’ç‰ˆæœ¬ï¼‰
      function medianCutPalette(colors, targetColors) {
        if (colors.length === 0) return [[0, 0, 0]];
        
        // é™åˆ¶æ ·æœ¬æ•°é‡é˜²æ­¢å†…å­˜é—®é¢˜
        const maxSamples = 10000;
        if (colors.length > maxSamples) {
          const step = Math.floor(colors.length / maxSamples);
          colors = colors.filter((_, i) => i % step === 0);
        }
        
        let buckets = [colors];
        
        // è¿­ä»£åˆ†å‰²ç›´åˆ°è¾¾åˆ°ç›®æ ‡é¢œè‰²æ•°
        while (buckets.length < targetColors && buckets.length < 256) {
          let maxVarianceBucket = null;
          let maxVariance = 0;
          let maxChannel = 0;
          
          // æ‰¾åˆ°æ–¹å·®æœ€å¤§çš„æ¡¶
          for (let bucket of buckets) {
            if (bucket.length <= 1) continue;
            
            for (let ch = 0; ch < 3; ch++) {
              const values = bucket.map(c => c[ch]);
              const min = Math.min(...values);
              const max = Math.max(...values);
              const variance = max - min;
              
              if (variance > maxVariance) {
                maxVariance = variance;
                maxVarianceBucket = bucket;
                maxChannel = ch;
              }
            }
          }
          
          if (!maxVarianceBucket || maxVarianceBucket.length <= 1) break;
          
          // åœ¨æœ€å¤§æ–¹å·®é€šé“ä¸Šåˆ†å‰²
          maxVarianceBucket.sort((a, b) => a[maxChannel] - b[maxChannel]);
          const mid = Math.floor(maxVarianceBucket.length / 2);
          
          const bucket1 = maxVarianceBucket.slice(0, mid);
          const bucket2 = maxVarianceBucket.slice(mid);
          
          // æ›¿æ¢åŸæ¡¶
          const index = buckets.indexOf(maxVarianceBucket);
          buckets.splice(index, 1, bucket1, bucket2);
        }
        
        // è®¡ç®—æ¯ä¸ªæ¡¶çš„å¹³å‡é¢œè‰²
        return buckets.map(bucket => {
          if (bucket.length === 0) return [0, 0, 0];
          const r = Math.round(bucket.reduce((s, c) => s + c[0], 0) / bucket.length);
          const g = Math.round(bucket.reduce((s, c) => s + c[1], 0) / bucket.length);
          const b = Math.round(bucket.reduce((s, c) => s + c[2], 0) / bucket.length);
          return [r, g, b];
        });
      }
      
      const paletteColors = medianCutPalette(samples, 256); // 256è‰²
      const palette = [];
      paletteColors.slice(0, 256).forEach(([r, g, b]) => {
        palette.push(r, g, b);
      });
      
      // å¡«å……åˆ°768å­—èŠ‚
      while (palette.length < 768) palette.push(0, 0, 0);
      return palette;
    }

    // è¾¹ç¼˜ä¿æŠ¤ç®—æ³•
    function convertWithEdgeProtection(frame, palette) {
      const pixels = frame.data;
      const width = frame.width;
      const height = frame.height;
      const indexed = [];
      
      // ç®€åŒ–çš„è¾¹ç¼˜æ£€æµ‹
      const isEdge = (x, y) => {
        if (x <= 0 || x >= width - 1 || y <= 0 || y >= height - 1) return false;
        const i = (y * width + x) * 4;
        const centerR = pixels[i], centerG = pixels[i+1], centerB = pixels[i+2];
        
        // åªæ£€æŸ¥4ä¸ªç›¸é‚»åƒç´ 
        const neighbors = [
          (i - width * 4), // ä¸Š
          (i + width * 4), // ä¸‹
          (i - 4),          // å·¦
          (i + 4)           // å³
        ];
        
        let maxDiff = 0;
        for (let ni of neighbors) {
          if (ni >= 0 && ni < pixels.length - 3) {
            const dr = Math.abs(pixels[ni] - centerR);
            const dg = Math.abs(pixels[ni+1] - centerG);
            const db = Math.abs(pixels[ni+2] - centerB);
            const diff = dr + dg + db;
            if (diff > maxDiff) maxDiff = diff;
          }
        }
        
        return maxDiff > 60; // ç®€åŒ–çš„è¾¹ç¼˜é˜ˆå€¼
      };
      
      // Floyd-Steinbergè¯¯å·®æ‰©æ•£çŸ©é˜µ
      const errorMatrix = Array(width * height * 3).fill(0);
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;
          const ei = (y * width + x) * 3;
          
          let r = Math.max(0, Math.min(255, pixels[i] + errorMatrix[ei]));
          let g = Math.max(0, Math.min(255, pixels[i+1] + errorMatrix[ei+1]));
          let b = Math.max(0, Math.min(255, pixels[i+2] + errorMatrix[ei+2]));
          
          // è¾¹ç¼˜åŒºåŸŸä½¿ç”¨æ›´ä¿å®ˆçš„é‡åŒ–
          const edge = isEdge(x, y);
          let bestIndex = 0, minDist = Infinity;
          let bestR = 0, bestG = 0, bestB = 0;
          
          for (let j = 0; j < palette.length; j += 3) {
            const pr = palette[j], pg = palette[j+1], pb = palette[j+2];
            let dist = (r-pr)*(r-pr) + (g-pg)*(g-pg) + (b-pb)*(b-pb);
            
            // è¾¹ç¼˜åŒºåŸŸåå‘é€‰æ‹©æ›´æ¥è¿‘çš„é¢œè‰²
            if (edge) dist *= 0.8;
            
            if (dist < minDist) {
              minDist = dist;
              bestIndex = j / 3;
              bestR = pr; bestG = pg; bestB = pb;
            }
          }
          
          indexed.push(bestIndex);
          
          // è¯¯å·®æ‰©æ•£ï¼ˆè¾¹ç¼˜åŒºåŸŸå‡å°‘æ‰©æ•£å¼ºåº¦ï¼‰
          const errorStrength = edge ? 0.5 : 1.0;
          const errR = (r - bestR) * errorStrength;
          const errG = (g - bestG) * errorStrength;
          const errB = (b - bestB) * errorStrength;
          
          // Floyd-Steinbergæ‰©æ•£æ¨¡å¼
          if (x + 1 < width) {
            const ni = (y * width + x + 1) * 3;
            errorMatrix[ni] += errR * 7/16;
            errorMatrix[ni+1] += errG * 7/16;
            errorMatrix[ni+2] += errB * 7/16;
          }
          if (y + 1 < height) {
            if (x > 0) {
              const ni = ((y+1) * width + x - 1) * 3;
              errorMatrix[ni] += errR * 3/16;
              errorMatrix[ni+1] += errG * 3/16;
              errorMatrix[ni+2] += errB * 3/16;
            }
            const ni = ((y+1) * width + x) * 3;
            errorMatrix[ni] += errR * 5/16;
            errorMatrix[ni+1] += errG * 5/16;
            errorMatrix[ni+2] += errB * 5/16;
            
            if (x + 1 < width) {
              const ni = ((y+1) * width + x + 1) * 3;
              errorMatrix[ni] += errR * 1/16;
              errorMatrix[ni+1] += errG * 1/16;
              errorMatrix[ni+2] += errB * 1/16;
            }
          }
        }
      }
      
      return indexed;
    }

    // Floyd-SteinbergæŠ–åŠ¨
    function convertWithDithering(frame, palette) {
      const pixels = frame.data;
      const width = frame.width;
      const height = frame.height;
      const indexed = [];
      const errorMatrix = Array(width * height * 3).fill(0);
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;
          const ei = (y * width + x) * 3;
          
          let r = Math.max(0, Math.min(255, pixels[i] + errorMatrix[ei]));
          let g = Math.max(0, Math.min(255, pixels[i+1] + errorMatrix[ei+1]));
          let b = Math.max(0, Math.min(255, pixels[i+2] + errorMatrix[ei+2]));
          
          let bestIndex = 0, minDist = Infinity;
          let bestR = 0, bestG = 0, bestB = 0;
          
          for (let j = 0; j < palette.length; j += 3) {
            const pr = palette[j], pg = palette[j+1], pb = palette[j+2];
            const dist = (r-pr)*(r-pr) + (g-pg)*(g-pg) + (b-pb)*(b-pb);
            if (dist < minDist) {
              minDist = dist;
              bestIndex = j / 3;
              bestR = pr; bestG = pg; bestB = pb;
            }
          }
          
          indexed.push(bestIndex);
          
          const errR = r - bestR;
          const errG = g - bestG;
          const errB = b - bestB;
          
          // è¯¯å·®æ‰©æ•£
          if (x + 1 < width) {
            const ni = (y * width + x + 1) * 3;
            errorMatrix[ni] += errR * 7/16;
            errorMatrix[ni+1] += errG * 7/16;
            errorMatrix[ni+2] += errB * 7/16;
          }
          if (y + 1 < height) {
            if (x > 0) {
              const ni = ((y+1) * width + x - 1) * 3;
              errorMatrix[ni] += errR * 3/16;
              errorMatrix[ni+1] += errG * 3/16;
              errorMatrix[ni+2] += errB * 3/16;
            }
            const ni = ((y+1) * width + x) * 3;
            errorMatrix[ni] += errR * 5/16;
            errorMatrix[ni+1] += errG * 5/16;
            errorMatrix[ni+2] += errB * 5/16;
            
            if (x + 1 < width) {
              const ni = ((y+1) * width + x + 1) * 3;
              errorMatrix[ni] += errR * 1/16;
              errorMatrix[ni+1] += errG * 1/16;
              errorMatrix[ni+2] += errB * 1/16;
            }
          }
        }
      }
      
      return indexed;
    }

    // ä¼˜åŒ–è°ƒè‰²æ¿è½¬æ¢
    function convertWithOptimizedPalette(frame, palette) {
      const pixels = frame.data;
      const indexed = [];
      
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i], g = pixels[i+1], b = pixels[i+2];
        let bestIndex = 0, minDist = Infinity;
        
        for (let j = 0; j < palette.length; j += 3) {
          const pr = palette[j], pg = palette[j+1], pb = palette[j+2];
          const dist = (r-pr)*(r-pr) + (g-pg)*(g-pg) + (b-pb)*(b-pb);
          if (dist < minDist) {
            minDist = dist;
            bestIndex = j / 3;
          }
        }
        
        indexed.push(bestIndex);
      }
      
      return indexed;
    }

    /**
     * LZWï¼ˆLempel-Ziv-Welchï¼‰å‹ç¼©ç®—æ³•
     * GIFæ ¼å¼æ ‡å‡†çš„å›¾åƒæ•°æ®å‹ç¼©æ–¹æ³•ï¼Œå°†ç´¢å¼•æ•°æ®è¿›ä¸€æ­¥å‹ç¼©
     * @param {Array} data - ç´¢å¼•é¢œè‰²æ•°æ®
     * @returns {Array} å‹ç¼©åçš„å­—èŠ‚æ•°ç»„
     */
    function compressLZW(data) {
      // LZWå‹ç¼©çš„ç‰¹æ®Šæ§åˆ¶ç 
      const clearCode = 256;  // æ¸…é™¤å­—å…¸ä¿¡å·
      const endCode = 257;    // æ•°æ®ç»“æŸä¿¡å·
      let nextCode = 258;     // ä¸‹ä¸€ä¸ªå¯ç”¨çš„å­—å…¸ä»£ç 
      let codeSize = 9;       // å½“å‰ä»£ç ä½æ•°
      
      const dictionary = new Map();  // å­—ç¬¦ä¸²åˆ°ä»£ç çš„æ˜ å°„å­—å…¸
      const result = [];             // è¾“å‡ºçš„å‹ç¼©æ•°æ®
      let bitBuffer = 0;             // ä½ç¼“å†²åŒº
      let bitCount = 0;              // ç¼“å†²åŒºä¸­çš„ä½æ•°
      
      // åˆå§‹åŒ–å­—å…¸ï¼š0-255ä¸ºåŸºç¡€å­—ç¬¦
      for (let i = 0; i < 256; i++) {
        dictionary.set(i.toString(), i);
      }
      
      /**
       * è¾“å‡ºä¸€ä¸ªLZWä»£ç åˆ°ç»“æœç¼“å†²åŒº
       * @param {number} code - è¦è¾“å‡ºçš„ä»£ç å€¼
       */
      function outputCode(code) {
        bitBuffer |= code << bitCount;  // å°†ä»£ç æ·»åŠ åˆ°ä½ç¼“å†²åŒº
        bitCount += codeSize;
        
        // å½“ç¼“å†²åŒºæœ‰è¶³å¤Ÿçš„ä½æ—¶ï¼Œè¾“å‡ºå­—èŠ‚
        while (bitCount >= 8) {
          result.push(bitBuffer & 0xFF);  // è¾“å‡ºä½8ä½
          bitBuffer >>= 8;                // å³ç§»8ä½
          bitCount -= 8;
        }
      }
      
      // å¼€å§‹å‹ç¼©ï¼šè¾“å‡ºæ¸…é™¤ä»£ç 
      outputCode(clearCode);
      
      // LZWä¸»å‹ç¼©å¾ªç¯
      let w = data[0].toString();  // å½“å‰å­—ç¬¦ä¸²
      for (let i = 1; i < data.length; i++) {
        const k = data[i].toString();    // æ–°å­—ç¬¦
        const wk = w + ',' + k;          // æ‰©å±•å­—ç¬¦ä¸²
        
        if (dictionary.has(wk)) {
          // å¦‚æœæ‰©å±•å­—ç¬¦ä¸²åœ¨å­—å…¸ä¸­ï¼Œç»§ç»­æ‰©å±•
          w = wk;
        } else {
          // è¾“å‡ºå½“å‰å­—ç¬¦ä¸²çš„ä»£ç 
          outputCode(dictionary.get(w));
          
          // å°†æ–°å­—ç¬¦ä¸²æ·»åŠ åˆ°å­—å…¸ï¼ˆå¦‚æœè¿˜æœ‰ç©ºé—´ï¼‰
          if (nextCode < 4096) {  // GIFæ ¼å¼é™åˆ¶æœ€å¤§ä»£ç æ•°
            dictionary.set(wk, nextCode++);
            
            // å½“å­—å…¸å¤§å°è¶…è¿‡å½“å‰ä»£ç ä½æ•°æ—¶ï¼Œå¢åŠ ä½æ•°
            if (nextCode > (1 << codeSize) && codeSize < 12) {
              codeSize++;
            }
          }
          
          // é‡æ–°å¼€å§‹æ–°çš„å­—ç¬¦ä¸²
          w = k;
        }
      }
      
      // è¾“å‡ºæœ€åçš„å­—ç¬¦ä¸²å’Œç»“æŸä»£ç 
      outputCode(dictionary.get(w));
      outputCode(endCode);
      
      // è¾“å‡ºç¼“å†²åŒºä¸­å‰©ä½™çš„ä½
      if (bitCount > 0) {
        result.push(bitBuffer & 0xFF);
      }
      
      return result;
    }

    /**
     * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„
     * ç”¨äºå°†GIFæ–‡ä»¶å¤´ä¿¡æ¯è½¬æ¢ä¸ºäºŒè¿›åˆ¶æ ¼å¼
     * @param {string} str - è¦è½¬æ¢çš„å­—ç¬¦ä¸²
     * @returns {Array} å­—èŠ‚æ•°ç»„
     */
    function stringToBytes(str) {
      return Array.from(str).map(c => c.charCodeAt(0));
    }

    // ==================================================
    // æµ‹è¯•åŠŸèƒ½ - ç”Ÿæˆç¤ºä¾‹GIFéªŒè¯ç³»ç»ŸåŠŸèƒ½
    // ==================================================
    
    /**
     * æµ‹è¯•GIFç”ŸæˆåŠŸèƒ½
     * åˆ›å»ºä¸€ä¸ªåŒ…å«å¤æ‚å›¾å½¢å’ŒåŠ¨ç”»çš„æµ‹è¯•GIFï¼Œç”¨äºéªŒè¯ç®—æ³•æ­£ç¡®æ€§
     */
    async function testGif() {
      try {
        showStatus('ğŸ§ª ç”Ÿæˆé«˜è´¨é‡æµ‹è¯•GIF...');
        
        const testFrames = [];
        for (let i = 0; i < 5; i++) { // å‡å°‘æµ‹è¯•å¸§æ•°
          const canvas = document.createElement('canvas');
          canvas.width = 150;
          canvas.height = 150;
          const ctx = canvas.getContext('2d');
          
          // å¤æ‚æ¸å˜èƒŒæ™¯
          const gradient = ctx.createRadialGradient(75, 75, 0, 75, 75, 75);
          gradient.addColorStop(0, `hsl(${i * 30}, 80%, 70%)`);
          gradient.addColorStop(0.5, `hsl(${i * 30 + 60}, 60%, 50%)`);
          gradient.addColorStop(1, `hsl(${i * 30 + 120}, 40%, 30%)`);
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 150, 150);
          
          // åŠ¨ç”»å›¾å½¢
          const angle = (i / 5) * Math.PI * 2;
          ctx.save();
          ctx.translate(75, 75);
          ctx.rotate(angle);
          
          // å¤æ‚å½¢çŠ¶
          ctx.fillStyle = `hsla(${(i * 45) % 360}, 90%, 60%, 0.8)`;
          ctx.beginPath();
          for (let j = 0; j < 6; j++) {
            const a = (j / 6) * Math.PI * 2;
            const r = 30 + Math.sin(i * 0.5) * 10;
            const x = Math.cos(a) * r;
            const y = Math.sin(a) * r;
            if (j === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          
          // æ·»åŠ ç»†èŠ‚
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          ctx.restore();
          
          // æ–‡å­—
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3;
          ctx.strokeText(`HQ${i+1}`, 75, 130);
          ctx.fillText(`HQ${i+1}`, 75, 130);
          
          testFrames.push(ctx.getImageData(0, 0, 150, 150));
        }
        
        const gifBuffer = await createLocalGif(testFrames, 5);
        const gifBlob = new Blob([gifBuffer], { type: 'image/gif' });
        const gifUrl = URL.createObjectURL(gifBlob);
        
        const img = new Image();
        img.onload = () => {
          const preview = gifResult.querySelector('.gif-preview');
          preview.innerHTML = '<h4>âœ… é«˜è´¨é‡æµ‹è¯•ç»“æœ</h4>';
          preview.appendChild(img);
          
          const downloadBtn = document.createElement('a');
          downloadBtn.href = gifUrl;
          downloadBtn.download = 'test-hq.gif';
          downloadBtn.textContent = 'ğŸ“¥ ä¸‹è½½æµ‹è¯•GIF';
          downloadBtn.className = 'download-btn';
          preview.appendChild(downloadBtn);
          
          showStatus(`âœ… é«˜è´¨é‡æµ‹è¯•å®Œæˆï¼æ–‡ä»¶å¤§å°ï¼š${(gifBlob.size / 1024).toFixed(1)}KB`, 'success');
        };
        
        img.src = gifUrl;
        
      } catch (error) {
        showStatus(`âŒ æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // ==================================================
    // ç”¨æˆ·ç•Œé¢äº¤äº’äº‹ä»¶å¤„ç†
    // ==================================================
    
    /**
     * èµ·å§‹æ—¶é—´è¾“å…¥æ¡†å˜åŒ–æ—¶çš„å®æ—¶é¢„è§ˆ
     * å½“ç”¨æˆ·è°ƒæ•´èµ·å§‹æ—¶é—´æ—¶ï¼Œè§†é¢‘ä¼šè‡ªåŠ¨è·³è½¬åˆ°å¯¹åº”ä½ç½®
     */
    startTimeInput.addEventListener('input', () => {
      if (video.src && video.duration > 0) {
        const startTime = parseFloat(startTimeInput.value);
        if (!isNaN(startTime) && startTime >= 0 && startTime < video.duration) {
          video.currentTime = startTime;
        }
      }
    });

    /**
     * é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
     * æ˜¾ç¤ºå°±ç»ªçŠ¶æ€ä¿¡æ¯
     */
    window.addEventListener('load', () => {
      setTimeout(() => {
        showStatus('âœ… é«˜è´¨é‡é˜²å¤±çœŸGIFç”Ÿæˆå™¨å·²å°±ç»ªï¼æ”¯æŒä»»æ„æ—¶é—´æ®µæå–ï¼', 'success');
      }, 500);
    });
  </script>
</body>
</html>